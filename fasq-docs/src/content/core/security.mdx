# Security Features 

FASQ includes comprehensive security features for production applications, ensuring sensitive data is protected and preventing common security vulnerabilities.

## Overview

The security features in FASQ are designed to:

- **Protect sensitive data** from persistence and unauthorized access
- **Encrypt data at rest** using platform-specific secure storage
- **Validate all inputs** to prevent injection attacks
- **Automatically clean up** sensitive data on app lifecycle events

## Secure Cache Entries

Mark sensitive data to prevent persistence and enable automatic cleanup:

```dart
QueryBuilder<String>(
  queryKey: 'auth-token',
  queryFn: () => api.getAuthToken(),
  options: QueryOptions(
    isSecure: true,                    // Mark as secure
    maxAge: Duration(minutes: 15),     // Required TTL for secure entries
    staleTime: Duration(minutes: 5),
  ),
  builder: (context, state) {
    // Secure data is never persisted to disk
    // Automatically cleared on app background
    return Text('Token: ${state.data}');
  },
)
```

### Security Benefits

- **Never persisted to disk** - Secure entries are memory-only
- **Automatic cleanup** - Cleared on app background/termination
- **Strict TTL enforcement** - Expired secure entries are immediately removed
- **Not exposed in DevTools** - Secure data is hidden from debugging tools

### Use Cases

Perfect for storing:
- Authentication tokens
- Personal information
- Payment details
- API keys
- Session data

## Encrypted Persistence

Optional encryption for persisted cache data using platform-specific secure storage:

```dart
final secureClient = QueryClient(
  config: const CacheConfig(
    defaultStaleTime: Duration(minutes: 5),
    defaultCacheTime: Duration(minutes: 10),
  ),
  persistenceOptions: const PersistenceOptions(enabled: true),
);

QueryClientProvider(
  client: secureClient,
  child: const MyApp(),
);
```

### Encryption Features

- **AES-GCM encryption** for data at rest
- **Platform-specific key storage**:
  - iOS: Keychain
  - Android: EncryptedSharedPreferences
  - Desktop: Platform-specific secure storage
- **Isolate-based encryption** for large data (>50KB)
- **Automatic key generation** and management

### Platform Support

| Platform | Key Storage | Status |
|----------|-------------|---------|
| iOS | Keychain | Supported |
| Android | EncryptedSharedPreferences | Supported |
| macOS | Keychain | Supported |
| Windows | Credential Manager | Supported |
| Linux | Secret Service | Supported |
| Web | Not supported | Throws error |

## Input Validation

Comprehensive validation prevents injection attacks and malformed data:

```dart
// Valid query keys
QueryBuilder<String>(
  queryKey: 'user:123',        // Valid
  queryFn: () => fetchUser(),
)

// Invalid query keys throw clear errors
QueryBuilder<String>(
  queryKey: 'user@123',        // Throws: "Query key must contain only alphanumeric, colon, hyphen, underscore"
  queryFn: () => fetchUser(),
)
```

### Validation Coverage

- **Query keys** - Alphanumeric, colon, hyphen, underscore only
- **Cache data** - No functions or closures allowed
- **Duration values** - Non-negative durations only
- **Clear error messages** - Actionable validation feedback

### Valid Query Key Patterns

```dart
// Valid patterns
'user:123'
'posts-list'
'profile_data'
'item_id-123_v2'
'key_with_underscores'
'key-with-hyphens'
'key:with:colons'
'KEY_WITH_CAPS'
'12345'

// Invalid patterns
'user@123'           // Special characters
'key with spaces'    // Spaces
'key.with.dots'      // Dots
'key$value'          // Special characters
```

## Security Configuration

Configure security features globally using `QueryClientProvider`:

```dart
final secureClient = QueryClient(
  config: const CacheConfig(
    defaultStaleTime: Duration(minutes: 5),
    defaultCacheTime: Duration(minutes: 10),
  ),
  persistenceOptions: const PersistenceOptions(enabled: true),
);

QueryClientProvider(
  client: secureClient,
  child: MaterialApp(
    home: const MyApp(),
  ),
);

// Access configured client in widgets
class MyWidget extends StatelessWidget {
  const MyWidget({super.key});

  @override
  Widget build(BuildContext context) {
    return QueryBuilder<String>(
      queryKey: StringQueryKey('secure-data'),
      queryFn: () => fetchSecureData(),
      options: QueryOptions(
        isSecure: true,
        maxAge: const Duration(minutes: 30),
      ),
      builder: (context, state) => Text('${state.data}'),
    );
  }
}
```

## Adapter Support

All FASQ adapters support security features:

### fasq_bloc

```dart
BlocProvider(
  create: (_) => QueryCubit<String>(
    key: 'auth-token',
    queryFn: () => api.getAuthToken(),
    options: QueryOptions(
      isSecure: true,
      maxAge: Duration(minutes: 15),
    ),
    client: context.queryClient,
  ),
  child: BlocBuilder<QueryCubit<String>, QueryState<String>>(
    builder: (context, state) => Text('${state.data}'),
  ),
)
```

### fasq_hooks

```dart
class SecureDataWidget extends HookWidget {
  @override
  Widget build(BuildContext context) {
    final client = context.queryClient;
    
    final secureQuery = useQuery<String>(
      'auth-token',
      () => api.getAuthToken(),
      options: QueryOptions(
        isSecure: true,
        maxAge: Duration(minutes: 15),
      ),
      client: client,
    );
    
    return Text('Token: ${secureQuery.data}');
  }
}
```

### fasq_riverpod

```dart
final secureTokenProvider = queryProvider<String>(
  'auth-token',
  () => api.getAuthToken(),
  options: QueryOptions(
    isSecure: true,
    maxAge: Duration(minutes: 15),
  ),
  client: context.queryClient,
);

class SecureTokenWidget extends ConsumerWidget {
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final state = ref.watch(secureTokenProvider);
    return Text('Token: ${state.data}');
  }
}
```

## Encryption Key Rotation

For enhanced security, you can rotate encryption keys to re-encrypt all cached data with a new key:

```dart
// Get the persister from your QueryClient
final persister = queryClient.persister as EncryptedCachePersister;

// Update encryption key with progress tracking
await persister.updateEncryptionKey(
  newEncryptionKey,
  onProgress: (current, total) {
    print('Re-encrypting: $current/$total');
    // Update UI progress indicator
  },
);
```

### Key Rotation Process

The key rotation process is atomic and safe:

1. **Validates new key** - Ensures the new key format is correct
2. **Retrieves all cached data** - Gets all existing encrypted entries
3. **Re-encrypts data** - Decrypts with old key, encrypts with new key
4. **Updates stored key** - Only after successful re-encryption
5. **Persists new data** - Writes all re-encrypted data
6. **Cleans up failures** - Removes any data that couldn't be re-encrypted

### Safety Features

- **Atomic operation** - Key only updated after successful re-encryption
- **Rollback on failure** - Old key restored if process fails
- **Graceful degradation** - Continues if individual entries fail
- **Progress tracking** - Optional callback for UI feedback
- **Early exit** - No operation if key hasn't changed

### When to Rotate Keys

Rotate encryption keys:
- **Regular intervals** - Monthly or quarterly for high-security apps
- **Security incidents** - After suspected data breaches
- **Key compromise** - If encryption key is exposed
- **Policy changes** - When security requirements change

### Best Practices for Key Rotation

```dart
// Good - Rotate during maintenance window
Future<void> rotateEncryptionKey() async {
  try {
    // Show loading indicator
    showLoadingDialog('Rotating encryption key...');
    
    await persister.updateEncryptionKey(
      generateNewEncryptionKey(),
      onProgress: (current, total) {
        updateProgressDialog(current, total);
      },
    );
    
    // Success
    showSuccessMessage('Encryption key rotated successfully');
  } catch (e) {
    // Handle failure
    showErrorMessage('Failed to rotate key: $e');
  } finally {
    hideLoadingDialog();
  }
}

// Bad - Don't rotate during active usage
Future<void> badKeyRotation() async {
  // This could cause data loss if app terminates during rotation
  await persister.updateEncryptionKey(newKey);
}
```

### Important Warnings

⚠️ **Process Duration**: Key rotation can take time for large datasets
⚠️ **App Termination**: Don't terminate the app during key rotation
⚠️ **Network Impact**: Cache may be temporarily unavailable during rotation
⚠️ **Maintenance Window**: Consider rotating during low-usage periods

### Error Handling

```dart
try {
  await persister.updateEncryptionKey(newKey);
} on EncryptionException catch (e) {
  // Invalid key format
  print('Invalid key: $e');
} on PersistenceException catch (e) {
  // Re-encryption failed, old key restored
  print('Rotation failed: $e');
}
```

Always mark sensitive data as secure:

```dart
// Good - Sensitive data marked as secure
QueryOptions(
  isSecure: true,
  maxAge: Duration(minutes: 15),
)

// Bad - Sensitive data not marked as secure
QueryOptions(
  isSecure: false, // Sensitive data could be persisted
)
```

### 2. Set Appropriate TTL Values

Use reasonable TTL values for secure entries:

```dart
// Good - Short TTL for sensitive data
QueryOptions(
  isSecure: true,
  maxAge: Duration(minutes: 15), // Short-lived tokens
)

// Bad - Too long TTL for sensitive data
QueryOptions(
  isSecure: true,
  maxAge: Duration(hours: 24), // Too long for sensitive data
)
```

### 3. Use Strong Encryption Keys

Generate strong encryption keys:

```dart
// Good - Strong encryption key
PersistenceOptions(
  enabled: true,
  encryptionKey: 'your-very-long-and-secure-encryption-key-here',
)

// Bad - Weak encryption key
PersistenceOptions(
  enabled: true,
  encryptionKey: '123', // Too short and weak
)
```

### 4. Validate All Inputs

Always validate query keys and data:

```dart
// Good - Valid query key
queryKey: 'user:123'

// Bad - Invalid query key
queryKey: 'user@123' // Will throw validation error
```

## Migration Guide

### Migrating to Security Package

The built-in security features have been moved to the dedicated `fasq_security` package. Follow these steps to migrate:

#### Step 1: Update Dependencies

```yaml
# Remove old dependencies
dependencies:
  fasq: ^0.2.0
  # Remove these:
  # encrypt: ^5.0.3
  # flutter_secure_storage: ^9.0.0

# Add new security package
dependencies:
  fasq: ^0.2.0
  fasq_security: ^0.0.1
```

#### Step 2: Update Imports

```dart
// Add security package import
import 'package:fasq_security/fasq_security.dart';
```

#### Step 3: Replace PersistenceOptions

```dart
// Before (deprecated)
QueryClientProvider(
  config: CacheConfig(),
  persistenceOptions: PersistenceOptions(
    enabled: true,
    encryptionKey: 'your-key',
  ),
  child: MyApp(),
)

// After (new security package)
QueryClientProvider(
  config: CacheConfig(),
  securityPlugin: DefaultSecurityPlugin(),
  child: MyApp(),
)
```

#### Step 4: Update Key Rotation Code

```dart
// Before (deprecated)
final persister = queryClient.persister as EncryptedCachePersister;
await persister.updateEncryptionKey('new-key');

// After (new security package)
final securityPlugin = DefaultSecurityPlugin();
await securityPlugin.initialize();
await securityPlugin.updateEncryptionKey('new-key');
```

### Enabling Security Features (Legacy)

For applications still using the legacy security features:

1. **Add security dependencies** to your `pubspec.yaml`:

```yaml
dependencies:
  fasq: ^0.2.0
  encrypt: ^5.0.3
  flutter_secure_storage: ^9.0.0
```

2. **Wrap your app** with `QueryClientProvider`:

```dart
QueryClientProvider(
  config: CacheConfig(
    defaultStaleTime: Duration(minutes: 5),
    defaultCacheTime: Duration(minutes: 10),
  ),
  persistenceOptions: PersistenceOptions(
    enabled: true,
    encryptionKey: 'your-encryption-key',
  ),
  child: MaterialApp(
    home: MyApp(),
  ),
)
```

3. **Mark sensitive queries** as secure:

```dart
QueryOptions(
  isSecure: true,
  maxAge: Duration(minutes: 15),
)
```

4. **Update adapter usage** to use configured client:

```dart
// Before
QueryCubit<String>(
  key: 'auth-token',
  queryFn: () => api.getAuthToken(),
)

// After
QueryCubit<String>(
  key: 'auth-token',
  queryFn: () => api.getAuthToken(),
  options: QueryOptions(
    isSecure: true,
    maxAge: Duration(minutes: 15),
  ),
  client: context.queryClient,
)
```

> **⚠️ Deprecation Notice**: The built-in security features are deprecated and will be removed in a future version. Please migrate to the `fasq_security` package for continued support and enhanced features.

## Security Package (fasq_security) 

FASQ now includes a dedicated security package (`fasq_security`) that provides enterprise-grade security features with a flexible plugin architecture. This package replaces the built-in security features with a more robust, extensible solution.

### Overview

The `fasq_security` package provides:

- **Military-grade encryption** - AES-256-GCM with authenticated encryption
- **️ Platform-specific secure storage** - Keychain, EncryptedSharedPreferences, etc.
- **SQLite persistence** - Type-safe database operations with Drift
- **Plugin architecture** - Customizable security providers
- **High performance** - Isolate-based encryption for large data
- **Key rotation** - Secure re-encryption of existing data

### Installation

Add the security package to your `pubspec.yaml`:

```yaml
dependencies:
  fasq: ^0.2.0
  fasq_security: ^0.0.1
```

### Quick Start

Replace the deprecated persistence options with the new security plugin:

```dart
import 'package:fasq_security/fasq_security.dart';

QueryClientProvider(
  config: CacheConfig(
    defaultStaleTime: Duration(minutes: 5),
    defaultCacheTime: Duration(minutes: 10),
  ),
  securityPlugin: DefaultSecurityPlugin(), // New security plugin
  child: MaterialApp(
    home: MyApp(),
  ),
)
```

### Default Security Plugin

The `DefaultSecurityPlugin` provides a complete security solution out of the box:

```dart
import 'package:fasq_security/fasq_security.dart';

// Initialize the security plugin
final securityPlugin = DefaultSecurityPlugin();
await securityPlugin.initialize();

// Use with QueryClientProvider
QueryClientProvider(
  config: CacheConfig(),
  securityPlugin: securityPlugin,
  child: MyApp(),
)
```

#### Features

- **CryptoEncryptionProvider** - AES-256-GCM encryption using pointycastle
- **SecureStorageProvider** - Platform-specific secure key storage
- **DriftPersistenceProvider** - SQLite database for encrypted data persistence

### Custom Security Implementation

Create your own security plugin by implementing the `SecurityPlugin` interface:

```dart
import 'package:fasq/fasq.dart';
import 'package:fasq_security/fasq_security.dart';

class CustomSecurityPlugin implements SecurityPlugin {
  @override
  String get name => 'Custom Security Plugin';
  
  @override
  String get version => '1.0.0';
  
  @override
  bool get isSupported => true;
  
  @override
  SecurityProvider createStorageProvider() {
    return CustomSecurityProvider();
  }
  
  @override
  EncryptionProvider createEncryptionProvider() {
    return CustomEncryptionProvider();
  }
  
  @override
  PersistenceProvider createPersistenceProvider() {
    return CustomPersistenceProvider();
  }
}

// Custom security provider implementation
class CustomSecurityProvider implements SecurityProvider {
  @override
  Future<void> initialize() async {
    // Initialize your custom security implementation
  }
  
  @override
  Future<String?> getEncryptionKey() async {
    // Return stored encryption key
    return 'your-custom-key';
  }
  
  @override
  Future<void> setEncryptionKey(String key) async {
    // Store encryption key securely
  }
  
  @override
  Future<void> deleteEncryptionKey() async {
    // Delete encryption key
  }
  
  @override
  bool get isSupported => true;
}

// Use your custom plugin
QueryClientProvider(
  config: CacheConfig(),
  securityPlugin: CustomSecurityPlugin(),
  child: MyApp(),
)
```

### Provider Interfaces

The security package defines three core interfaces:

#### SecurityProvider

Manages encryption key storage:

```dart
abstract class SecurityProvider {
  Future<void> initialize();
  Future<String?> getEncryptionKey();
  Future<void> setEncryptionKey(String key);
  Future<void> deleteEncryptionKey();
  bool get isSupported;
}
```

#### EncryptionProvider

Handles data encryption/decryption:

```dart
abstract class EncryptionProvider {
  Future<List<int>> encrypt(List<int> data, String key);
  Future<List<int>> decrypt(List<int> data, String key);
  String generateKey();
  bool isValidKey(String key);
}
```

#### PersistenceProvider

Manages encrypted data persistence:

```dart
abstract class PersistenceProvider {
  Future<void> initialize();
  Future<void> persist(String key, List<int> encryptedData);
  Future<List<int>?> retrieve(String key);
  Future<void> remove(String key);
  Future<void> clear();
  Future<bool> exists(String key);
  Future<List<String>> getAllKeys();
  Future<void> persistMultiple(Map<String, List<int>> entries);
  Future<Map<String, List<int>>> retrieveMultiple(List<String> keys);
  Future<void> removeMultiple(List<String> keys);
}
```

### Advanced Usage

#### Key Rotation

Rotate encryption keys securely:

```dart
final securityPlugin = DefaultSecurityPlugin();
await securityPlugin.initialize();

// Update encryption key
await securityPlugin.updateEncryptionKey('new-encryption-key');
```

#### Manual Provider Access

Access individual providers for advanced operations:

```dart
final securityPlugin = DefaultSecurityPlugin();
await securityPlugin.initialize();

// Generate and store a new key
final key = await securityPlugin.storageProvider.generateAndStoreKey();

// Encrypt data manually
final data = [1, 2, 3, 4, 5];
final encrypted = await securityPlugin.encryptionProvider.encrypt(data, key);

// Persist encrypted data
await securityPlugin.persistenceProvider.persist('my-key', encrypted);
```

#### Error Handling

Handle security-specific exceptions:

```dart
import 'package:fasq_security/fasq_security.dart';

try {
  await securityPlugin.updateEncryptionKey('new-key');
} on EncryptionException catch (e) {
  print('Encryption failed: $e');
} on PersistenceException catch (e) {
  print('Persistence failed: $e');
} on SecurityException catch (e) {
  print('Security operation failed: $e');
}
```

### Integration with Adapters

All FASQ adapters work seamlessly with the security package:

#### fasq_bloc

```dart
BlocProvider(
  create: (_) => QueryCubit<String>(
    key: 'auth-token',
    queryFn: () => api.getAuthToken(),
    options: QueryOptions(
      isSecure: true,
      maxAge: Duration(minutes: 15),
    ),
    client: context.queryClient, // Uses configured security plugin
  ),
  child: BlocBuilder<QueryCubit<String>, QueryState<String>>(
    builder: (context, state) => Text('${state.data}'),
  ),
)
```

#### fasq_hooks

```dart
class SecureDataWidget extends HookWidget {
  @override
  Widget build(BuildContext context) {
    final client = context.queryClient; // Uses configured security plugin
    
    final secureQuery = useQuery<String>(
      'auth-token',
      () => api.getAuthToken(),
      options: QueryOptions(
        isSecure: true,
        maxAge: Duration(minutes: 15),
      ),
      client: client,
    );
    
    return Text('Token: ${secureQuery.data}');
  }
}
```

#### fasq_riverpod

```dart
final secureTokenProvider = queryProvider<String>(
  'auth-token',
  () => api.getAuthToken(),
  options: QueryOptions(
    isSecure: true,
    maxAge: Duration(minutes: 15),
  ),
  client: context.queryClient, // Uses configured security plugin
);
```

### Migration from Built-in Security

#### Step 1: Update Dependencies

```yaml
# Before
dependencies:
  fasq: ^0.1.0
  encrypt: ^5.0.3
  flutter_secure_storage: ^9.0.0

# After
dependencies:
  fasq: ^0.2.0
  fasq_security: ^0.0.1
```

#### Step 2: Replace PersistenceOptions

```dart
// Before
QueryClientProvider(
  config: CacheConfig(),
  persistenceOptions: PersistenceOptions(
    enabled: true,
    encryptionKey: 'your-key',
  ),
  child: MyApp(),
)

// After
QueryClientProvider(
  config: CacheConfig(),
  securityPlugin: DefaultSecurityPlugin(),
  child: MyApp(),
)
```

#### Step 3: Update Key Rotation

```dart
// Before
final persister = queryClient.persister as EncryptedCachePersister;
await persister.updateEncryptionKey('new-key');

// After
final securityPlugin = DefaultSecurityPlugin();
await securityPlugin.initialize();
await securityPlugin.updateEncryptionKey('new-key');
```

### Platform Support

| Platform | Secure Storage | Encryption | Persistence | Status |
|----------|---------------|------------|-------------|---------|
| iOS | Keychain | AES-256-GCM | SQLite | Supported |
| Android | EncryptedSharedPreferences | AES-256-GCM | SQLite | Supported |
| macOS | Keychain | AES-256-GCM | SQLite | Supported |
| Windows | Credential Manager | AES-256-GCM | SQLite | Supported |
| Linux | Secret Service | AES-256-GCM | SQLite | Supported |
| Web | Not supported | AES-256-GCM | Not supported | ⚠️ Limited |

### Performance Considerations

- **Large data encryption** (>50KB) automatically uses background isolates
- **SQLite persistence** provides better performance than SharedPreferences
- **Batch operations** available for multiple data operations
- **Connection pooling** for efficient database access

### Security Best Practices

1. **Use DefaultSecurityPlugin** for most applications
2. **Implement custom plugins** only when necessary
3. **Rotate encryption keys** regularly for high-security apps
4. **Validate all inputs** before encryption
5. **Handle exceptions** gracefully in production
6. **Test security features** thoroughly before deployment

### Troubleshooting

#### Common Issues

**Plugin initialization fails:**
- Ensure all required dependencies are installed
- Check platform support for secure storage
- Verify proper initialization sequence

**Encryption/decryption errors:**
- Validate key format and length
- Check data integrity before encryption
- Ensure proper error handling

**Persistence issues:**
- Verify database permissions
- Check available storage space
- Ensure proper transaction handling

## Troubleshooting

### Common Issues

**Encryption not working on web:**
- Web platform doesn't support secure storage
- Use `isSecure: true` for web-sensitive data instead

**Validation errors:**
- Check query key format (alphanumeric, colon, hyphen, underscore only)
- Ensure durations are non-negative
- Verify cache data doesn't contain functions

**Performance issues:**
- Large data (>50KB) is automatically encrypted in isolates
- Consider reducing cache size for better performance
- Use appropriate TTL values to prevent memory bloat

### Error Messages

| Error | Cause | Solution |
|-------|-------|----------|
| "Query key must contain only alphanumeric, colon, hyphen, underscore" | Invalid query key format | Use valid characters only |
| "Secure queries must specify maxAge for TTL enforcement" | Missing maxAge for secure query | Add maxAge to QueryOptions |
| "staleTime must be non-negative" | Negative duration | Use positive or zero duration |
| "Cache data cannot be a function or closure" | Function in cache data | Remove functions from cached data |
