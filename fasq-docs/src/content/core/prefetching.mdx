# Prefetching

Prefetching allows you to warm the cache with data before it's explicitly requested by a UI component. This enables predictive loading, faster user experiences, and reduced loading states.

## What is Prefetching?

Prefetching is the process of fetching data in the background and storing it in the cache before the user actually needs it. When the user navigates to a screen or hovers over a link, the data is already available, resulting in instant loading.

## Core Prefetch API

### Manual Prefetching

The `QueryClient` provides methods for manual prefetching:

```dart
final client = QueryClient();

// Prefetch a single query
await client.prefetchQuery(
  'users',
  () => api.fetchUsers(),
);

// Prefetch multiple queries in parallel
await client.prefetchQueries([
  PrefetchConfig(key: 'users', queryFn: () => api.fetchUsers()),
  PrefetchConfig(key: 'posts', queryFn: () => api.fetchPosts()),
  PrefetchConfig(key: 'comments', queryFn: () => api.fetchComments()),
]);
```

### PrefetchConfig

Use `PrefetchConfig` to define multiple queries for batch prefetching:

```dart
class PrefetchConfig<T> {
  final String key;
  final Future<T> Function() queryFn;
  final QueryOptions? options;
  
  const PrefetchConfig({
    required this.key,
    required this.queryFn,
    this.options,
  });
}
```

## Cache Behavior

### Silent Background Fetches

Prefetched queries execute silently in the background without exposing loading states to the UI. This means:

- No loading indicators are shown
- No error states are displayed
- The prefetch operation is transparent to the user

### Cache Population

When a query is prefetched:

1. The data is fetched using the provided `queryFn`
2. The result is stored in the cache with the specified key
3. The temporary query instance is disposed
4. Subsequent queries with the same key will use the cached data

### Staleness Check

Prefetching respects cache staleness:

```dart
// If cache is fresh, prefetch is skipped
final cachedEntry = cache.get('users');
if (cachedEntry != null && cachedEntry.isFresh) {
  return; // Skip prefetch
}
```

## Performance Considerations

### When to Prefetch

Prefetching is most effective when:

- **Navigation**: Prefetch data for the next likely screen
- **Hover**: Prefetch on hover for links or buttons
- **Mount**: Prefetch related data when a component mounts
- **Tab Changes**: Prefetch data for inactive tabs

### Batch Prefetching

Use `prefetchQueries` for multiple related queries:

```dart
// More efficient than individual prefetches
await client.prefetchQueries([
  PrefetchConfig(key: 'user-profile', queryFn: () => api.fetchUser(userId)),
  PrefetchConfig(key: 'user-posts', queryFn: () => api.fetchUserPosts(userId)),
  PrefetchConfig(key: 'user-followers', queryFn: () => api.fetchUserFollowers(userId)),
]);
```

## Best Practices

### 1. Prefetch Strategically

Only prefetch data that users are likely to need:

```dart
// Good: Prefetch on hover for likely navigation
onHover: () => prefetch('user-123', () => api.fetchUser('123'));

// Avoid: Prefetching everything on app start
useEffect(() => {
  prefetchAllData(); // Too aggressive
}, []);
```

### 2. Use Appropriate Cache Times

Set reasonable cache times for prefetched data:

```dart
await client.prefetchQuery(
  'users',
  () => api.fetchUsers(),
  options: QueryOptions(
    staleTime: Duration(minutes: 5), // Fresh for 5 minutes
    cacheTime: Duration(hours: 1),   // Cached for 1 hour
  ),
);
```

### 3. Handle Errors Gracefully

Prefetch errors should not break the user experience:

```dart
try {
  await client.prefetchQuery('users', () => api.fetchUsers());
} catch (e) {
  // Log error but don't show to user
  logger.warning('Prefetch failed: $e');
}
```

### 4. Respect Network Conditions

Consider network conditions when prefetching:

```dart
if (isWifiConnection && !isLowBattery) {
  await client.prefetchQuery('heavy-data', () => api.fetchHeavyData());
}
```

## Integration Patterns

### Route-Based Prefetching

Prefetch data before navigation:

```dart
class NavigationService {
  Future<void> navigateToUserProfile(String userId) async {
    // Prefetch user data before navigation
    await queryClient.prefetchQuery(
      'user-$userId',
      () => api.fetchUser(userId),
    );
    
    // Navigate to profile screen
    router.push('/user/$userId');
  }
}
```

### Component-Based Prefetching

Prefetch related data when components mount:

```dart
class UserDashboard extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    // Prefetch related data on mount
    useEffect(() {
      queryClient.prefetchQueries([
        PrefetchConfig(key: 'user-stats', queryFn: () => api.fetchUserStats()),
        PrefetchConfig(key: 'recent-activity', queryFn: () => api.fetchRecentActivity()),
      ]);
      return null;
    }, []);
    
    return DashboardContent();
  }
}
```

## Testing Prefetching

Test prefetching behavior:

```dart
test('prefetch populates cache correctly', () async {
  final client = QueryClient();
  
  await client.prefetchQuery('test-key', () => Future.value('test-data'));
  
  final cachedData = client.cache.get('test-key');
  expect(cachedData?.data, equals('test-data'));
});

test('prefetch skips if cache is fresh', () async {
  final client = QueryClient();
  int fetchCount = 0;
  
  Future<String> fetchData() async {
    fetchCount++;
    return 'test-data';
  }
  
  // First prefetch
  await client.prefetchQuery('test-key', fetchData);
  expect(fetchCount, equals(1));
  
  // Second prefetch should be skipped
  await client.prefetchQuery('test-key', fetchData);
  expect(fetchCount, equals(1)); // Still 1
});
```

Prefetching is a powerful tool for improving user experience by reducing loading times and making your app feel more responsive. Use it strategically to anticipate user needs and provide instant data access.
