# QueryState

The `QueryState` represents the current state of a query in Fasq. It contains information about the query's status, data, errors, and metadata.

## Basic Structure

```dart
class QueryState<T> {
  final T? data;           // The fetched data
  final Object? error;      // The error if any
  final StackTrace? stackTrace; // Stack trace for errors
  final QueryStatus status; // Current status: idle, loading, success, or error
  final bool isLoading;     // True when loading
  final bool hasData;       // True when data is available
  final bool hasError;      // True when error occurred
  final bool isSuccess;     // True when successfully loaded
  final bool isFetching;    // True when refetching in background
  final bool isIdle;        // True when not yet executed
  final DateTime? lastUpdated; // When the data was last updated
  final int fetchCount;    // Number of times this query has been fetched
}
```

## Status Enum

```dart
enum QueryStatus {
  idle,     // Query has not been executed yet
  loading,  // Query is currently fetching data
  success,  // Query completed successfully
  error,    // Query failed with an error
}
```

## Basic Usage

```dart
class QueryStateExample extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return QueryBuilder<List<User>>(
      queryKey: 'users',
      queryFn: () => api.fetchUsers(),
      builder: (context, state) {
        // Access different properties of QueryState
        print('Status: ${state.status}');
        print('Is Loading: ${state.isLoading}');
        print('Has Data: ${state.hasData}');
        print('Has Error: ${state.hasError}');
        print('Fetch Count: ${state.fetchCount}');
        
        return Column(
          children: [
            Text('Status: ${state.status}'),
            Text('Fetch Count: ${state.fetchCount}'),
            if (state.lastUpdated != null)
              Text('Last Updated: ${state.lastUpdated}'),
          ],
        );
      },
    );
  }
}
```

## Status Handling

### Using Status Enum

```dart
class StatusHandlingExample extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return QueryBuilder<List<User>>(
      queryKey: 'users',
      queryFn: () => api.fetchUsers(),
      builder: (context, state) {
        switch (state.status) {
          case QueryStatus.idle:
            return Center(child: Text('Ready to fetch users'));
          case QueryStatus.loading:
            return Center(child: CircularProgressIndicator());
          case QueryStatus.success:
            return ListView.builder(
              itemCount: state.data!.length,
              itemBuilder: (context, index) {
                final user = state.data![index];
                return ListTile(title: Text(user.name));
              },
            );
          case QueryStatus.error:
            return Center(child: Text('Error: ${state.error}'));
        }
      },
    );
  }
}
```

### Using Boolean Properties

```dart
class BooleanPropertiesExample extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return QueryBuilder<List<User>>(
      queryKey: 'users',
      queryFn: () => api.fetchUsers(),
      builder: (context, state) {
        if (state.isIdle) {
          return Center(child: Text('Click to load users'));
        }
        
        if (state.isLoading) {
          return Center(child: CircularProgressIndicator());
        }
        
        if (state.hasError) {
          return Center(child: Text('Error: ${state.error}'));
        }
        
        if (state.hasData) {
          return ListView.builder(
            itemCount: state.data!.length,
            itemBuilder: (context, index) {
              final user = state.data![index];
              return ListTile(title: Text(user.name));
            },
          );
        }
        
        return Center(child: Text('No data'));
      },
    );
  }
}
```

## Data Access

### Safe Data Access

```dart
class SafeDataAccess extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return QueryBuilder<List<User>>(
      queryKey: 'users',
      queryFn: () => api.fetchUsers(),
      builder: (context, state) {
        // Safe data access with null checks
        if (state.hasData && state.data != null) {
          final users = state.data!;
          return ListView.builder(
            itemCount: users.length,
            itemBuilder: (context, index) {
              final user = users[index];
              return ListTile(
                title: Text(user.name),
                subtitle: Text(user.email),
              );
            },
          );
        }
        
        return Center(child: Text('No users available'));
      },
    );
  }
}
```

### Type-Safe Data Access

```dart
class TypeSafeDataAccess extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return QueryBuilder<List<User>>(
      queryKey: 'users',
      queryFn: () => api.fetchUsers(),
      builder: (context, state) {
        // Type-safe data access
        final users = state.data; // List<User>?
        
        if (users != null) {
          return Column(
            children: [
              Text('Total Users: ${users.length}'),
              Expanded(
                child: ListView.builder(
                  itemCount: users.length,
                  itemBuilder: (context, index) {
                    final user = users[index]; // User type
                    return ListTile(
                      title: Text(user.name),
                      subtitle: Text(user.email),
                    );
                  },
                ),
              ),
            ],
          );
        }
        
        return Center(child: Text('No users loaded'));
      },
    );
  }
}
```

## Error Handling

### Error State Management

```dart
class ErrorHandlingExample extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return QueryBuilder<List<User>>(
      queryKey: 'users',
      queryFn: () => api.fetchUsers(),
      builder: (context, state) {
        if (state.hasError) {
          return Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              Icon(Icons.error, size: 64, color: Colors.red),
              SizedBox(height: 16),
              Text('Error: ${state.error}'),
              if (state.stackTrace != null)
                Text('Stack Trace: ${state.stackTrace}'),
              SizedBox(height: 16),
              ElevatedButton(
                onPressed: () {
                  // Retry the query
                  QueryClient().getQueryByKey<List<User>>('users')?.fetch();
                },
                child: Text('Retry'),
              ),
            ],
          );
        }
        
        if (state.hasData) {
          return ListView.builder(
            itemCount: state.data!.length,
            itemBuilder: (context, index) {
              final user = state.data![index];
              return ListTile(title: Text(user.name));
            },
          );
        }
        
        return Center(child: CircularProgressIndicator());
      },
    );
  }
}
```

### Error Recovery

```dart
class ErrorRecoveryExample extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return QueryBuilder<List<User>>(
      queryKey: 'users',
      queryFn: () => api.fetchUsers(),
      builder: (context, state) {
        if (state.hasError) {
          return ErrorRecoveryWidget(
            error: state.error!,
            stackTrace: state.stackTrace,
            onRetry: () {
              // Clear error and retry
              QueryClient().invalidateQuery('users');
            },
          );
        }
        
        return state.when(
          idle: () => Center(child: Text('Ready to load')),
          loading: () => Center(child: CircularProgressIndicator()),
          data: (users) => UserList(users: users),
        );
      },
    );
  }
}

class ErrorRecoveryWidget extends StatelessWidget {
  final Object error;
  final StackTrace? stackTrace;
  final VoidCallback onRetry;
  
  const ErrorRecoveryWidget({
    required this.error,
    this.stackTrace,
    required this.onRetry,
  });
  
  @override
  Widget build(BuildContext context) {
    return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Icon(Icons.error_outline, size: 64, color: Colors.red),
          SizedBox(height: 16),
          Text('Something went wrong'),
          SizedBox(height: 8),
          Text('$error'),
          if (stackTrace != null) ...[
            SizedBox(height: 8),
            Text('Stack Trace: $stackTrace'),
          ],
          SizedBox(height: 16),
          ElevatedButton(
            onPressed: onRetry,
            child: Text('Try Again'),
          ),
        ],
      ),
    );
  }
}
```

## Background Refetching

### Handling Background Updates

```dart
class BackgroundRefetchExample extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return QueryBuilder<List<User>>(
      queryKey: 'users',
      queryFn: () => api.fetchUsers(),
      options: QueryOptions(
        staleTime: Duration(minutes: 1), // Data becomes stale after 1 minute
      ),
      builder: (context, state) {
        return Column(
          children: [
            // Show background refresh indicator
            if (state.isFetching && !state.isLoading)
              LinearProgressIndicator(),
            
            // Show last updated time
            if (state.lastUpdated != null)
              Text('Last updated: ${state.lastUpdated}'),
            
            // Show fetch count
            Text('Fetched ${state.fetchCount} times'),
            
            // Show data
            Expanded(
              child: state.when(
                idle: () => Center(child: Text('Ready to load users')),
                loading: () => Center(child: CircularProgressIndicator()),
                error: (error, stack) => Center(child: Text('Error: $error')),
                data: (users) => ListView.builder(
                  itemCount: users.length,
                  itemBuilder: (context, index) {
                    final user = users[index];
                    return ListTile(
                      title: Text(user.name),
                      subtitle: Text(user.email),
                    );
                  },
                ),
              ),
            ),
          ],
        );
      },
    );
  }
}
```

### Stale Data Handling

```dart
class StaleDataExample extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return QueryBuilder<List<User>>(
      queryKey: 'users',
      queryFn: () => api.fetchUsers(),
      options: QueryOptions(
        staleTime: Duration(minutes: 5),
      ),
      builder: (context, state) {
        return Column(
          children: [
            // Show data freshness indicator
            if (state.hasData && state.lastUpdated != null)
              _buildFreshnessIndicator(state.lastUpdated!),
            
            // Show data
            Expanded(
              child: state.when(
                loading: () => Center(child: CircularProgressIndicator()),
                error: (error, stack) => Center(child: Text('Error: $error')),
                data: (users) => ListView.builder(
                  itemCount: users.length,
                  itemBuilder: (context, index) {
                    final user = users[index];
                    return ListTile(title: Text(user.name));
                  },
                ),
              ),
            ),
          ],
        );
      },
    );
  }
  
  Widget _buildFreshnessIndicator(DateTime lastUpdated) {
    final age = DateTime.now().difference(lastUpdated);
    final isStale = age.inMinutes > 5;
    
    return Container(
      padding: EdgeInsets.all(8),
      color: isStale ? Colors.orange : Colors.green,
      child: Row(
        children: [
          Icon(
            isStale ? Icons.warning : Icons.check_circle,
            color: Colors.white,
          ),
          SizedBox(width: 8),
          Text(
            isStale ? 'Data is stale' : 'Data is fresh',
            style: TextStyle(color: Colors.white),
          ),
        ],
      ),
    );
  }
}
```

## State Transitions

### Monitoring State Changes

```dart
class StateTransitionExample extends StatefulWidget {
  @override
  State<StateTransitionExample> createState() => _StateTransitionExampleState();
}

class _StateTransitionExampleState extends State<StateTransitionExample> {
  QueryStatus? _previousStatus;
  int _transitionCount = 0;
  
  @override
  Widget build(BuildContext context) {
    return QueryBuilder<List<User>>(
      queryKey: 'users',
      queryFn: () => api.fetchUsers(),
      builder: (context, state) {
        // Monitor state transitions
        if (_previousStatus != null && _previousStatus != state.status) {
          _transitionCount++;
          print('State transition: $_previousStatus -> ${state.status}');
        }
        _previousStatus = state.status;
        
        return Column(
          children: [
            Text('Current Status: ${state.status}'),
            Text('Transitions: $_transitionCount'),
            Text('Fetch Count: ${state.fetchCount}'),
            
            ElevatedButton(
              onPressed: () {
                // Trigger state transition
                QueryClient().invalidateQuery('users');
              },
              child: Text('Trigger Refetch'),
            ),
            
            Expanded(
              child: state.when(
                idle: () => Center(child: Text('Ready to load')),
                loading: () => Center(child: CircularProgressIndicator()),
                error: (error, stack) => Center(child: Text('Error: $error')),
                data: (users) => ListView.builder(
                  itemCount: users.length,
                  itemBuilder: (context, index) {
                    final user = users[index];
                    return ListTile(title: Text(user.name));
                  },
                ),
              ),
            ),
          ],
        );
      },
    );
  }
}
```

## Common Patterns

### Loading States

```dart
class LoadingStatesExample extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return QueryBuilder<List<User>>(
      queryKey: 'users',
      queryFn: () => api.fetchUsers(),
      builder: (context, state) {
        if (state.isLoading) {
          return _buildLoadingState();
        }
        
        if (state.isFetching && !state.isLoading) {
          return _buildRefreshingState();
        }
        
        return state.when(
          error: (error, stack) => _buildErrorState(error),
          data: (users) => _buildDataState(users),
        );
      },
    );
  }
  
  Widget _buildLoadingState() {
    return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          CircularProgressIndicator(),
          SizedBox(height: 16),
          Text('Loading users...'),
        ],
      ),
    );
  }
  
  Widget _buildRefreshingState() {
    return Column(
      children: [
        LinearProgressIndicator(),
        Expanded(
          child: Center(child: Text('Refreshing data...')),
        ),
      ],
    );
  }
  
  Widget _buildErrorState(Object error) {
    return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Icon(Icons.error, size: 64, color: Colors.red),
          SizedBox(height: 16),
          Text('Error: $error'),
        ],
      ),
    );
  }
  
  Widget _buildDataState(List<User> users) {
    return ListView.builder(
      itemCount: users.length,
      itemBuilder: (context, index) {
        final user = users[index];
        return ListTile(title: Text(user.name));
      },
    );
  }
}
```

### Empty States

```dart
class EmptyStatesExample extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return QueryBuilder<List<User>>(
      queryKey: 'users',
      queryFn: () => api.fetchUsers(),
      builder: (context, state) {
        return state.when(
          idle: () => _buildIdleState(),
          loading: () => _buildLoadingState(),
          error: (error, stack) => _buildErrorState(error),
          data: (users) => users.isEmpty 
            ? _buildEmptyState() 
            : _buildDataState(users),
        );
      },
    );
  }
  
  Widget _buildIdleState() {
    return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Icon(Icons.people, size: 64, color: Colors.grey),
          SizedBox(height: 16),
          Text('Ready to load users'),
          SizedBox(height: 8),
          Text('Tap the button to start'),
        ],
      ),
    );
  }
  
  Widget _buildLoadingState() {
    return Center(child: CircularProgressIndicator());
  }
  
  Widget _buildErrorState(Object error) {
    return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Icon(Icons.error, size: 64, color: Colors.red),
          SizedBox(height: 16),
          Text('Error: $error'),
        ],
      ),
    );
  }
  
  Widget _buildEmptyState() {
    return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Icon(Icons.people_outline, size: 64, color: Colors.grey),
          SizedBox(height: 16),
          Text('No users found'),
          SizedBox(height: 8),
          Text('Try refreshing or check your connection'),
        ],
      ),
    );
  }
  
  Widget _buildDataState(List<User> users) {
    return ListView.builder(
      itemCount: users.length,
      itemBuilder: (context, index) {
        final user = users[index];
        return ListTile(title: Text(user.name));
      },
    );
  }
}
```

## Performance Tips

1. **Use appropriate status checks** - Choose between `status` enum and boolean properties
2. **Handle all states** - Don't forget idle and error states
3. **Provide loading feedback** - Show progress indicators for better UX
4. **Handle errors gracefully** - Provide retry mechanisms
5. **Monitor state transitions** - Debug state changes when needed
6. **Use type-safe access** - Leverage generic types for compile-time safety
7. **Optimize re-renders** - Use specific state properties to avoid unnecessary rebuilds

## Next Steps

- **[QueryOptions](/docs/core/query-options)** - Learn about configuration options
- **[Cache Configuration](/docs/core/cache-configuration)** - Learn about cache policies
- **[Cache Invalidation](/docs/core/cache-invalidation)** - Learn about invalidation strategies
- **[Error Handling](/docs/core/error-handling)** - Learn about error handling patterns
