# Combining Queries

Combine multiple query providers into a single provider with Riverpod.

## Dynamic Query Combiners

### Index-based Access with combineQueries

```dart
import 'package:fasq_riverpod/fasq_riverpod.dart';

// Define individual providers
final usersProvider = queryProvider('users', () => api.fetchUsers());
final postsProvider = queryProvider('posts', () => api.fetchPosts());
final commentsProvider = queryProvider('comments', () => api.fetchComments());

// Combine providers
final dashboardProvider = combineQueries([usersProvider, postsProvider, commentsProvider]);

class Dashboard extends ConsumerWidget {
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final combined = ref.watch(dashboardProvider);

    return Column(
      children: [
        if (!combined.isAllSuccess) LinearProgressIndicator(),
        if (combined.hasAnyError) ErrorBanner(),
        UsersList(combined.getState<List<User>>(0)),
        PostsList(combined.getState<List<Post>>(1)),
        CommentsList(combined.getState<List<Comment>>(2)),
      ],
    );
  }
}
```

### Named Access with combineNamedQueries

```dart
import 'package:fasq_riverpod/fasq_riverpod.dart';

// Define individual providers
final usersProvider = queryProvider('users', () => api.fetchUsers());
final postsProvider = queryProvider('posts', () => api.fetchPosts());
final commentsProvider = queryProvider('comments', () => api.fetchComments());

// Combine providers with names
final dashboardProvider = combineNamedQueries({
  'users': usersProvider,
  'posts': postsProvider,
  'comments': commentsProvider,
});

class Dashboard extends ConsumerWidget {
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final combined = ref.watch(dashboardProvider);

    return Column(
      children: [
        if (!combined.isAllSuccess) LinearProgressIndicator(),
        if (combined.hasAnyError) ErrorBanner(),
        UsersList(combined.getState<List<User>>('users')),
        PostsList(combined.getState<List<Post>>('posts')),
        CommentsList(combined.getState<List<Comment>>('comments')),
      ],
    );
  }
}
```

## API Reference

### combineQueries

```dart
Provider<CombinedQueriesState> combineQueries(
  List<StateNotifierProvider<QueryNotifier<dynamic>, QueryState<dynamic>>> providers,
)
```

**Parameters:**
- `providers`: List of query providers to combine

**Returns:**
- `Provider<CombinedQueriesState>`: Provider that watches all query providers

### combineNamedQueries

```dart
Provider<NamedQueriesState> combineNamedQueries(
  Map<String, StateNotifierProvider<QueryNotifier<dynamic>, QueryState<dynamic>>> providers,
)
```

**Parameters:**
- `providers`: Map of query providers keyed by name

**Returns:**
- `Provider<NamedQueriesState>`: Provider that watches all query providers

### CombinedQueriesState

```dart
class CombinedQueriesState {
  final List<QueryState<dynamic>> states;
  
  // Aggregate state helpers
  bool get isAllLoading;    // True if all queries are loading
  bool get isAnyLoading;    // True if any query is loading
  bool get isAllSuccess;    // True if all queries succeeded
  bool get hasAnyError;     // True if any query has error
  bool get isAllData;       // True if all queries have data
  
  // Index-based access
  QueryState<T> getState<T>(int index);  // Get state by index
  int get length;                        // Number of queries
}
```

### NamedQueriesState

```dart
class NamedQueriesState {
  final Map<String, QueryState<dynamic>> states;
  
  // Aggregate state helpers
  bool get isAllLoading;    // True if all queries are loading
  bool get isAnyLoading;    // True if any query is loading
  bool get isAllSuccess;    // True if all queries succeeded
  bool get hasAnyError;     // True if any query has error
  bool get isAllData;       // True if all queries have data
  
  // Named access methods
  QueryState<T> getState<T>(String name);  // Get state by name
  bool isLoading(String name);            // Check if specific query is loading
  bool hasError(String name);             // Check if specific query has error
  int get length;                          // Number of queries
}
```

## Migration from Fixed Combiners

### From combineQueries2/3

**Old API:**
```dart
final combinedProvider = combineQueries3(usersProvider, postsProvider, commentsProvider);

// Access states
final combined = ref.watch(combinedProvider);
final userState = combined.state1;
final postState = combined.state2;
final commentState = combined.state3;
```

**New API (Index-based):**
```dart
final combinedProvider = combineQueries([usersProvider, postsProvider, commentsProvider]);

// Access states
final combined = ref.watch(combinedProvider);
final userState = combined.getState<List<User>>(0);
final postState = combined.getState<List<Post>>(1);
final commentState = combined.getState<List<Comment>>(2);
```

**New API (Named):**
```dart
final combinedProvider = combineNamedQueries({
  'users': usersProvider,
  'posts': postsProvider,
  'comments': commentsProvider,
});

// Access states
final combined = ref.watch(combinedProvider);
final userState = combined.getState<List<User>>('users');
final postState = combined.getState<List<Post>>('posts');
final commentState = combined.getState<List<Comment>>('comments');
```

## Benefits of Dynamic Combiners

### Scalability
- **No Limits**: Support any number of queries (not limited to 2-3)
- **Flexible**: Add or remove queries without changing the API

### Better Developer Experience
- **Named Access**: Use meaningful names instead of indices
- **Type Safety**: Compile-time checking for query names
- **Self-Documenting**: Code is more readable and maintainable

### Consistency
- **Unified API**: Same pattern across all adapters
- **Future-Proof**: Easy to extend with new features

## Advanced Patterns

### Conditional Providers

```dart
class ConditionalDashboard extends ConsumerWidget {
  final bool loadComments;
  
  const ConditionalDashboard({required this.loadComments});
  
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final providers = [
      usersProvider,
      postsProvider,
      if (loadComments) commentsProvider,
    ];
    
    final combinedProvider = combineQueries(providers);
    final combined = ref.watch(combinedProvider);
    
    return Column(
      children: [
        UsersList(combined.getState<List<User>>(0)),
        PostsList(combined.getState<List<Post>>(1)),
        if (loadComments) CommentsList(combined.getState<List<Comment>>(2)),
      ],
    );
  }
}
```

### Dynamic Provider Lists

```dart
class DynamicDashboard extends ConsumerWidget {
  final List<String> userIds;
  
  const DynamicDashboard({required this.userIds});
  
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final providers = userIds.map((id) => 
      queryProvider('user-$id', () => api.fetchUser(id))
    ).toList();
    
    final combinedProvider = combineQueries(providers);
    final combined = ref.watch(combinedProvider);
    
    return Column(
      children: userIds.asMap().entries.map((entry) {
        final index = entry.key;
        final userId = entry.value;
        final userState = combined.getState<User>(index);
        
        return UserCard(
          userId: userId,
          state: userState,
        );
      }).toList(),
    );
  }
}
```

### Error Handling

```dart
class ErrorHandlingDashboard extends ConsumerWidget {
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final combined = ref.watch(dashboardProvider);
    
    if (combined.hasAnyError) {
      final errorStates = combined.states.where((s) => s.hasError).toList();
      
      return ErrorBanner(
        errors: errorStates.map((s) => s.error).toList(),
        onRetry: () {
          for (final state in errorStates) {
            state.refetch();
          }
        },
      );
    }
    
    return Column(
      children: [
        UsersList(combined.getState<List<User>>(0)),
        PostsList(combined.getState<List<Post>>(1)),
        CommentsList(combined.getState<List<Comment>>(2)),
      ],
    );
  }
}
```

## Performance Tips

### Stable Provider Lists

```dart
// ✅ Good: Stable list reference
class Dashboard extends ConsumerWidget {
  static final _providers = [
    usersProvider,
    postsProvider,
    commentsProvider,
  ];
  
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final combinedProvider = combineQueries(_providers);
    final combined = ref.watch(combinedProvider);
    // ...
  }
}

// ❌ Avoid: Creating new list on each render
class Dashboard extends ConsumerWidget {
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final combinedProvider = combineQueries([
      usersProvider,
      postsProvider,
      commentsProvider,
    ]);
    final combined = ref.watch(combinedProvider);
    // ...
  }
}
```

### Memoized Provider Maps

```dart
// ✅ Good: Memoized map for named queries
class NamedDashboard extends ConsumerWidget {
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final providersMap = useMemoized(() => {
      'users': usersProvider,
      'posts': postsProvider,
      'comments': commentsProvider,
    }, []);
    
    final combinedProvider = combineNamedQueries(providersMap);
    final combined = ref.watch(combinedProvider);
    // ...
  }
}
```

## Testing

```dart
testWidgets('combineQueries works correctly', (tester) async {
  await tester.pumpWidget(
    ProviderScope(
      child: MaterialApp(
        home: Consumer(
          builder: (context, ref, child) {
            final combined = ref.watch(dashboardProvider);
            
            return Column(
              children: [
                Text('loading: ${combined.isAnyLoading}'),
                Text('success: ${combined.isAllSuccess}'),
                Text('users: ${combined.getState<String>(0).data ?? 'null'}'),
                Text('posts: ${combined.getState<String>(1).data ?? 'null'}'),
              ],
            );
          },
        ),
      ),
    ),
  );

  await tester.pumpAndSettle();
  
  expect(find.text('loading: false'), findsOneWidget);
  expect(find.text('success: true'), findsOneWidget);
  expect(find.text('users: users'), findsOneWidget);
  expect(find.text('posts: posts'), findsOneWidget);
});
```

## Common Pitfalls

### 1. Provider List Changes
```dart
// ❌ Bad: Changing provider list on each render
Widget build(BuildContext context, WidgetRef ref) {
  final providers = [usersProvider];
  if (someCondition) providers.add(postsProvider);
  
  final combinedProvider = combineQueries(providers);
  // ...
}

// ✅ Good: Stable provider list
Widget build(BuildContext context, WidgetRef ref) {
  final providers = someCondition 
    ? [usersProvider, postsProvider]
    : [usersProvider];
    
  final combinedProvider = combineQueries(providers);
  // ...
}
```

### 2. Index Out of Bounds
```dart
// ❌ Bad: Assuming specific indices exist
Widget build(BuildContext context, WidgetRef ref) {
  final combined = ref.watch(dashboardProvider);
  return UsersList(combined.getState<List<User>>(0)); // Could crash
}

// ✅ Good: Check bounds
Widget build(BuildContext context, WidgetRef ref) {
  final combined = ref.watch(dashboardProvider);
  if (combined.length > 0) {
    return UsersList(combined.getState<List<User>>(0));
  }
  return const SizedBox();
}
```

### 3. Missing Error Handling
```dart
// ❌ Bad: No error handling
Widget build(BuildContext context, WidgetRef ref) {
  final combined = ref.watch(dashboardProvider);
  return Column(
    children: [
      UsersList(combined.getState<List<User>>(0)),
      PostsList(combined.getState<List<Post>>(1)),
    ],
  );
}

// ✅ Good: Handle errors
Widget build(BuildContext context, WidgetRef ref) {
  final combined = ref.watch(dashboardProvider);
  
  if (combined.hasAnyError) {
    return ErrorWidget();
  }
  
  return Column(
    children: [
      UsersList(combined.getState<List<User>>(0)),
      PostsList(combined.getState<List<Post>>(1)),
    ],
  );
}
```