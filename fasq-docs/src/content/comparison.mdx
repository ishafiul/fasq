---
title: Comparison & Ecosystem Roles
description: How Fasq compares to other state management and data fetching libraries in the Flutter ecosystem.
---

## Fasq in the Ecosystem

Unlike general-purpose state managers (Riverpod, Bloc, Provider) which aim to solve **all** state needs, Fasq is a **specialized server-state manager**.

### Role: Complementary vs. Competitive

- **Vs. General State Managers**: Fasq is **complementary**. It is designed to handle the "messy" parts of async data (caching, invalidation, deduplication) so your global state managers can focus on business logic.
- **Vs. Manual API Handling**: Fasq is **competitive**. It replaces the boilerplate of manually fetching, loading, and storing API responses in custom classes.

---

## The State Spectrum

To understand where Fasq fits, it's helpful to categorize different types of state:

| State Type                | Description                                                                   | Preferred Tool               |
| ------------------------- | ----------------------------------------------------------------------------- | ---------------------------- |
| **Local / UI State**      | Logic that stays within a single widget (e.g., current tab, form focus)       | `StatefulWidget`, `setState` |
| **Global / Client State** | Logic shared across the app (e.g., user session, theme, navigation)           | Bloc, Riverpod, Provider     |
| **Server / Remote State** | Data that lives on a server (e.g., product lists, API responses, cached data) | **Fasq**                     |

## Technical Comparison (Vs. General State Managers)

### Paradigm Differences

| Aspect              | General State (Riverpod/Bloc)   | Fasq                              |
| ------------------- | ------------------------------- | --------------------------------- |
| **Source of Truth** | Memory / Local Store            | Server / Cache                    |
| **Data Ownership**  | Explicitly managed by developer | Managed by Cache Keys             |
| **Life Cycle**      | Up to the developer             | Reference-counted (automatic)     |
| **Caching Logic**   | Requires manual implementation  | Built-in (Stale-while-revalidate) |

### Feature Comparison

| Feature               | Standard Manager                | Fasq                       |
| --------------------- | ------------------------------- | -------------------------- |
| **Async Loading**     | via `FutureProvider` or `Cubit` | First-class `QueryBuilder` |
| **Automatic Retries** | Manual                          | Built-in                   |
| **Request Dedup**     | Manual / Partial                | Automatic                  |
| **Persistence**       | Manual / Custom                 | Integrated via Plugins     |
| **Circuit Breaker**   | Manual                          | Built-in                   |
| **Pagination**        | Manual                          | Built-in Infinite Queries  |

---

## When to Use Which?

### Use a General State Manager (Riverpod/Bloc) when:

- You are managing complex UI flows or state machines.
- You have highly reactive, client-side derived state.
- You need a single centralized store for the entire app's logic.
- You require 100% stable, community-vetted tools with extensive DevTools support.

### Use Fasq when:

- Your app is heavily data-driven from multiple API endpoints.
- You want to eliminate the "loading-success-error" boilerplate for every fetch.
- You need sophisticated caching, background refetching, and request deduplication.
- You want to separate "Server Data" from "App Business Logic".
- **You need enterprise-grade resilience features (Circuit Breakers, Security).**

### Use Both (Recommended) when:

- You use Fasq for the data-fetching layer and Bloc/Riverpod for cross-cutting app logic (auth, navigation) and complex feature flows.

---

## Architectural Comparison: Fetching User Data

### Theoretical comparison of implementation costs

| Complexity                    | Manual (Bloc/Cubit)          | Fasq      |
| ----------------------------- | ---------------------------- | --------- |
| **Initial Fetch**             | Low (boilerplate)            | Low       |
| **Loading/Error Handling**    | Medium (boilerplate)         | Automatic |
| **Basic Caching**             | High (manual store + checks) | Automatic |
| **Background Refetching**     | Very High                    | Automatic |
| **Offline Queue for Updates** | Very High                    | Automatic |

---

## Ecosystem Maturity

Fasq is a younger package compared to industry giants.

| Feature                | Bloc / Riverpod | Fasq                  |
| ---------------------- | --------------- | --------------------- |
| **Community Size**     | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê      | ‚≠ê‚≠ê                  |
| **Stable Release**     | ‚úÖ 1.0+         | ‚ö†Ô∏è 0.4.0 (Beta)       |
| **Tooling / DevTools** | ‚úÖ Extensive    | ‚ùå Experimental       |
| **Education / Docs**   | ‚úÖ Vast         | ‚ö†Ô∏è Developing         |
| **Adapters**           | N/A             | ‚ö†Ô∏è WIP (Experimental) |

> [!NOTE]
> The FASQ adapter packages (`fasq_bloc`, `fasq_riverpod`, etc.) are currently in an **experimental state**. They are intended to help bridge the gap for teams who want the caching power of Fasq while staying within their chosen state management architecture.

---

# Comparison & Ecosystem Roles

Fasq occupies a specific niche in the Flutter state management landscape. This page helps you understand the architectural role of Fasq compared to other popular solutions.

## At a Glance

| Feature                 | **Fasq**                                       | **TanStack Query (Flutter)** | **fquery / fl_query**    | **Riverpod / Bloc**     |
| :---------------------- | :--------------------------------------------- | :--------------------------- | :----------------------- | :---------------------- |
| **Primary Focus**       | Async State & Caching                          | Async State & Caching        | Async State & Caching    | Global State Management |
| **Architectural Fit**   | **Agnostic** (Works with Bloc, Riverpod, etc.) | Standalone                   | Hook-centric             | Centralized / Monolith  |
| **Caching Strategy**    | `Stale-While-Revalidate`                       | `Stale-While-Revalidate`     | `Stale-While-Revalidate` | Manual / Custom         |
| **Performance**         | **High** (Isolates, Hot Cache)                 | Standard                     | Standard                 | Varies                  |
| **Enterprise Features** | ‚úÖ **Security, Circuit Breaker**               | ‚ùå                           | ‚ùå                       | ‚ùå                      |

---

## Comparison: Fasq vs Other Query Packages

Packages like `flutter_tanstack_query`, `fquery`, and `fl_query` are excellent libraries that brought the "Query" paradigm to Flutter. Here's how Fasq distinguishes itself:

### 1. Enterprise-Grade Features üõ°Ô∏è

Fasq is built with complex, large-scale applications in mind.

- **Circuit Breakers**: Built-in support to prevent cascading failures when APIs are down. Service unavailability is handled gracefully without custom logic.
- **Security Plugin**: `fasq_security` offers encrypted storage and automatic clearing of sensitive data on app backgrounding‚Äîcritical for fintech and healthcare apps.
- **Performance Tuning**: Explicit controls for `Isolate` usage and `hotCache` to ensure heavy data transformations don't block the UI thread.

### 2. Architecture Agnostic ü§ù

While some packages are heavily tied to `flutter_hooks` or their own widget ecosystem, Fasq provides first-party adapters:

- `fasq_bloc`: Integrate queries directly into your Blocs.
- `fasq_riverpod`: Use queries as Providers.
- `fasq_hooks`: Use `useQuery` if you love hooks.
- **Pure Dart**: Run queries in pure Dart code (CLI, background services) without Flutter dependencies.

### 3. Developer Experience üõ†Ô∏è

- **Type Safety**: Strict typing avoids `dynamic` guessing games.
- **Global Observers**: Powerful `QueryClientObserver` pattern for centralized logging, analytics, and error reporting, rather than just simple callbacks.

---

## Feature Matrix

| Feature                | Fasq                        | Other Query Libs |
| :--------------------- | :-------------------------- | :--------------- |
| **Query Cancellation** | ‚úÖ (via `CancelToken`)      | ‚úÖ               |
| **Infinite Scrolling** | ‚úÖ (Bi-directional)         | ‚úÖ               |
| **Offline Mutations**  | ‚úÖ (Queue & Retry)          | ‚úÖ               |
| **Optimistic Updates** | ‚úÖ                          | ‚úÖ               |
| **Dependent Queries**  | ‚úÖ (`enabled`, `dependsOn`) | ‚úÖ               |
| **Prefetching**        | ‚úÖ (Parallel support)       | ‚úÖ               |
| **Persisters**         | ‚úÖ (Extensible)             | ‚úÖ (Hive/etc)    |
| **Garbage Collection** | ‚úÖ (Configurable)           | ‚úÖ               |
| **Circuit Breaker**    | ‚úÖ **Native Support**       | ‚ùå Manual Setup  |
| **Encrypted Cache**    | ‚úÖ **Native Support**       | ‚ùå Manual Setup  |
| **Isolate Offloading** | ‚úÖ **Native Support**       | ‚ùå Manual Setup  |

## Future Roadmap & Community

We are actively evolving Fasq. Our goal is to identify what's missing in current solutions and bridge those gaps. We are constantly researching, iterating, and looking for feedback to make Fasq the most robust server-state manager for Flutter. If you find a feature missing or have a specific use case, please open an issue!
