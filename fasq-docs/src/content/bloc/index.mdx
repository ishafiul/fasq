# Bloc Adapter

The Bloc adapter provides seamless integration with `flutter_bloc` through `QueryCubit` and `MutationCubit` classes.

## Overview

The Bloc adapter provides:

- **QueryCubit** - Cubit wrapper for queries
- **MutationCubit** - Cubit for server mutations
- **BlocBuilder/BlocConsumer** - Standard Bloc widgets work as expected
- **Bloc DevTools** - Full integration with Bloc DevTools

## When to Use Bloc Adapter

Use the Bloc adapter when:
- You're already using `flutter_bloc`
- You prefer structured state management
- You want explicit state transitions
- You need Bloc DevTools integration

## Installation

```yaml
dependencies:
  fasq_bloc: ^0.1.0
  flutter_bloc: ^8.0.0
```

## Basic Usage

Extend `QueryCubit` and implement the required getters:

```dart
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:fasq_bloc/fasq_bloc.dart';

class UsersQueryCubit extends QueryCubit<List<User>> {
  @override
  String get key => 'users';

  @override
  Future<List<User>> Function() get queryFn => () => api.fetchUsers();

  @override
  QueryOptions? get options => QueryOptions(
    staleTime: Duration(minutes: 5),
  );
}

class UsersScreen extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return BlocProvider(
      create: (_) => UsersQueryCubit(),
      child: BlocBuilder<UsersQueryCubit, QueryState<List<User>>>(
        builder: (context, state) {
          if (state.isLoading) {
            return CircularProgressIndicator();
          }
          
          if (state.hasError) {
            return Text('Error: ${state.error}');
          }
          
          if (state.hasData) {
            return ListView.builder(
              itemCount: state.data!.length,
              itemBuilder: (context, index) {
                final user = state.data![index];
                return ListTile(
                  title: Text(user.name),
                  subtitle: Text(user.email),
                );
              },
            );
          }
          
          return SizedBox();
        },
      ),
    );
  }
}
```

## Key Features

### Structured State Management

QueryCubit provides explicit state management with clear state transitions:

```dart
class UserProfileQueryCubit extends QueryCubit<User> {
  final String userId;

  UserProfileQueryCubit(this.userId);

  @override
  String get key => 'user:$userId';

  @override
  Future<User> Function() get queryFn => () => api.fetchUser(userId);
}

class UserProfile extends StatelessWidget {
  final String userId;
  
  const UserProfile({required this.userId});
  
  @override
  Widget build(BuildContext context) {
    return BlocProvider(
      create: (_) => UserProfileQueryCubit(userId),
      child: BlocBuilder<UserProfileQueryCubit, QueryState<User>>(
        builder: (context, state) {
          switch (state.status) {
            case QueryStatus.idle:
              return Text('Ready to fetch');
            case QueryStatus.loading:
              return CircularProgressIndicator();
            case QueryStatus.success:
              return UserDetails(state.data!);
            case QueryStatus.error:
              return Text('Error: ${state.error}');
          }
        },
      ),
    );
  }
}
```

### Manual Refetch

Control when queries are refetched:

```dart
class UserList extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Column(
      children: [
        ElevatedButton(
          onPressed: () {
            context.read<UsersQueryCubit>().refetch();
          },
          child: Text('Refresh'),
        ),
        BlocBuilder<UsersQueryCubit, QueryState<List<User>>>(
          builder: (context, state) => buildUI(state),
        ),
      ],
    );
  }
}
```

### Mutations with MutationCubit

Use MutationCubit for creating, updating, or deleting data:

```dart
class CreateUserMutationCubit extends MutationCubit<User, String> {
  @override
  Future<User> Function(String variables) get mutationFn => 
    (name) => api.createUser(name);

  @override
  MutationOptions<User, String>? get options => MutationOptions(
    onSuccess: (user) {
      print('Created user: ${user.name}');
      QueryClient().invalidateQuery('users');
    },
    onError: (error) {
      print('Error: $error');
    },
  );
}

class CreateUserScreen extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return BlocProvider(
      create: (_) => CreateUserMutationCubit(),
      child: BlocBuilder<CreateUserMutationCubit, MutationState<User>>(
        builder: (context, state) {
          return Column(
            children: [
              if (state.isLoading)
                CircularProgressIndicator(),
              
              if (state.hasError)
                Text('Error: ${state.error}'),
              
              if (state.hasData)
                Text('Created: ${state.data!.name}'),
              
              ElevatedButton(
                onPressed: state.isLoading
                    ? null
                    : () {
                        context.read<CreateUserMutationCubit>().mutate('John Doe');
                      },
                child: Text('Create User'),
              ),
            ],
          );
        },
      ),
    );
  }
}
```

### Cache Invalidation

Invalidate queries using Bloc context:

```dart
class MyWidget extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return ElevatedButton(
      onPressed: () {
        final cubit = context.read<UsersQueryCubit>();
        
        cubit.invalidate();
        
        QueryClient().invalidateQuery('users');
        QueryClient().invalidateQueriesWithPrefix('user:');
      },
      child: Text('Invalidate Cache'),
    );
  }
}
```

## Advanced Patterns

### Using BlocConsumer for Side Effects

```dart
BlocConsumer<UserProfileQueryCubit, QueryState<User>>(
  listener: (context, state) {
    if (state.hasError) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text('Error: ${state.error}')),
      );
    }
    
    if (state.isFetching) {
      print('Background refresh in progress...');
    }
  },
  builder: (context, state) {
    if (state.isLoading) return CircularProgressIndicator();
    if (state.hasData) return UserDetails(state.data!);
    return SizedBox();
  },
)
```

### Multiple Queries in One Screen

```dart
MultiBlocProvider(
  providers: [
    BlocProvider(create: (_) => UsersQueryCubit()),
    BlocProvider(create: (_) => PostsQueryCubit()),
  ],
  child: MyScreen(),
)
```

### Form Submission

```dart
class CreateUserFormMutationCubit extends MutationCubit<User, Map<String, String>> {
  @override
  Future<User> Function(Map<String, String> variables) get mutationFn => 
    (data) => api.createUser(data);

  @override
  MutationOptions<User, Map<String, String>>? get options => MutationOptions(
    onSuccess: (user) {
      print('User created: ${user.name}');
    },
  );
}

class CreateUserForm extends StatefulWidget {
  @override
  _CreateUserFormState createState() => _CreateUserFormState();
}

class _CreateUserFormState extends State<CreateUserForm> {
  final _nameController = TextEditingController();
  final _emailController = TextEditingController();

  @override
  Widget build(BuildContext context) {
    return BlocProvider(
      create: (_) => CreateUserFormMutationCubit(),
      child: BlocConsumer<CreateUserFormMutationCubit, MutationState<User>>(
        listener: (context, state) {
          if (state.hasData) {
            ScaffoldMessenger.of(context).showSnackBar(
              SnackBar(content: Text('User created: ${state.data!.name}')),
            );
            _nameController.clear();
            _emailController.clear();
          }
        },
        builder: (context, state) {
          return Column(
            children: [
              TextField(
                controller: _nameController,
                decoration: InputDecoration(labelText: 'Name'),
              ),
              TextField(
                controller: _emailController,
                decoration: InputDecoration(labelText: 'Email'),
              ),
              ElevatedButton(
                onPressed: state.isLoading
                    ? null
                    : () {
                        context.read<CreateUserFormMutationCubit>().mutate({
                          'name': _nameController.text,
                          'email': _emailController.text,
                        });
                      },
                child: state.isLoading
                    ? CircularProgressIndicator()
                    : Text('Create User'),
              ),
            ],
          );
        },
      ),
    );
  }
}
```

### Background Refetch Indicator

```dart
BlocBuilder<UsersQueryCubit, QueryState<List<User>>>(
  builder: (context, state) {
    return Column(
      children: [
        if (state.isFetching)
          LinearProgressIndicator(),
        
        if (state.hasData)
          Expanded(
            child: ListView.builder(
              itemCount: state.data!.length,
              itemBuilder: (context, index) => UserTile(state.data![index]),
            ),
          ),
      ],
    );
  },
)
```

## Testing

Test QueryCubit and MutationCubit like any other Cubit:

```dart
class TestUsersQueryCubit extends QueryCubit<List<User>> {
  @override
  String get key => 'users';

  @override
  Future<List<User>> Function() get queryFn => () => api.fetchUsers();
}

void main() {
  group('QueryCubit', () {
    late TestUsersQueryCubit cubit;
    
    setUp(() {
      cubit = TestUsersQueryCubit();
    });
    
    tearDown(() {
      cubit.close();
    });
    
    test('initial state is idle', () {
      expect(cubit.state.status, QueryStatus.idle);
    });
    
    test('emits loading then success when query succeeds', () async {
      final users = [User(id: '1', name: 'John')];
      when(() => api.fetchUsers()).thenAnswer((_) async => users);
      
      cubit.refetch();
      
      await expectLater(
        cubit.stream,
        emitsInOrder([
          predicate<QueryState<List<User>>>((state) => state.isLoading),
          predicate<QueryState<List<User>>>((state) => 
            state.hasData && state.data == users),
        ]),
      );
    });
  });
}
```

## Type Safety

Full generic type support ensures compile-time safety:

```dart
class UserScreen extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return BlocProvider(
      create: (_) => UsersQueryCubit(),
      child: BlocBuilder<UsersQueryCubit, QueryState<List<User>>>(
        builder: (context, state) {
          if (state.hasData) {
            return ListView.builder(
              itemCount: state.data!.length,
              itemBuilder: (context, index) {
                final user = state.data![index];
                return UserTile(user);
              },
            );
          }
          
          return CircularProgressIndicator();
        },
      ),
    );
  }
}
```

## Performance Benefits

- **Explicit state management** - Clear state transitions
- **Bloc DevTools integration** - Debug with familiar tools
- **Testable** - Easy to test cubits
- **Memory efficient** - Automatic cleanup on close

## Comparison with Core Package

**Core Package (QueryBuilder):**
```dart
QueryBuilder<List<User>>(
  queryKey: 'users',
  queryFn: () => api.fetchUsers(),
  builder: (context, state) {
    if (state.isLoading) return Loading();
    return UserList(state.data!);
  },
)
```

**Bloc Adapter (QueryCubit):**
```dart
class UsersQueryCubit extends QueryCubit<List<User>> {
  @override
  String get key => 'users';
  
  @override
  Future<List<User>> Function() get queryFn => () => api.fetchUsers();
}

BlocProvider(
  create: (_) => UsersQueryCubit(),
  child: BlocBuilder<UsersQueryCubit, QueryState<List<User>>>(
    builder: (context, state) {
      if (state.isLoading) return Loading();
      return UserList(state.data!);
    },
  ),
)
```

Both approaches use the same underlying query engine and have identical performance.

## Next Steps

- **[QueryCubit](/docs/bloc/query-cubit)** - Deep dive into QueryCubit
- **[MutationCubit](/docs/bloc/mutation-cubit)** - Learn about mutations
- **[Bloc Patterns](/docs/bloc/bloc-patterns)** - Advanced Bloc patterns
- **[Testing](/docs/bloc/testing)** - Testing strategies
- **[Examples](/docs/bloc/examples)** - Complete working examples
