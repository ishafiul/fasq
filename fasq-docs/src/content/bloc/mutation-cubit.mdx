# MutationCubit

The `MutationCubit` is an abstract base class for performing server-side mutations, emitting `MutationState` changes. Extend it to create cubits that handle operations that modify data on the server.

## Basic Usage

Extend `MutationCubit` and implement the required getter:

```dart
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:fasq_bloc/fasq_bloc.dart';

class CreateUserMutationCubit extends MutationCubit<User, String> {
  @override
  Future<User> Function(String variables) get mutationFn => 
    (name) => api.createUser(name);
}

class CreateUserScreen extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text('Create User')),
      body: BlocProvider(
        create: (context) => CreateUserMutationCubit(),
        child: BlocBuilder<CreateUserMutationCubit, MutationState<User>>(
          builder: (context, state) {
            return Column(
              children: [
                ElevatedButton(
                  onPressed: state.isLoading 
                    ? null 
                    : () {
                        context.read<CreateUserMutationCubit>().mutate('John Doe');
                      },
                  child: state.isLoading
                    ? CircularProgressIndicator()
                    : Text('Create User'),
                ),
                if (state.hasError)
                  Text('Error: ${state.error}'),
                if (state.hasData)
                  Text('Created: ${state.data!.name}'),
              ],
            );
          },
        ),
      ),
    );
  }
}
```

## Cubit Configuration

Configure mutation behavior by overriding the `options` getter:

```dart
class CreateUserMutationCubit extends MutationCubit<User, String> {
  @override
  Future<User> Function(String variables) get mutationFn => 
    (name) => api.createUser(name);

  @override
  MutationOptions<User, String>? get options => MutationOptions(
    onSuccess: (user) {
      print('User created: ${user.name}');
      QueryClient().invalidateQuery('users');
    },
    onError: (error) {
      print('Error creating user: $error');
    },
  );
}
```

## Status Handling

Handle different mutation statuses:

```dart
class CreateUserMutationCubit extends MutationCubit<User, String> {
  @override
  Future<User> Function(String variables) get mutationFn => 
    (name) => api.createUser(name);
}

class CreateUserScreen extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text('Create User')),
      body: BlocProvider(
        create: (context) => CreateUserMutationCubit(),
        child: BlocBuilder<CreateUserMutationCubit, MutationState<User>>(
          builder: (context, state) {
            switch (state.status) {
              case MutationStatus.idle:
                return ElevatedButton(
                  onPressed: () {
                    context.read<CreateUserMutationCubit>().mutate('John Doe');
                  },
                  child: Text('Create User'),
                );
              case MutationStatus.loading:
                return CircularProgressIndicator();
              case MutationStatus.success:
                return Text('Created: ${state.data!.name}');
              case MutationStatus.error:
                return Text('Error: ${state.error}');
            }
          },
        ),
      ),
    );
  }
}
```

## Form Submission

Handle form submissions with mutations:

```dart
class CreateUserFormMutationCubit extends MutationCubit<User, Map<String, String>> {
  @override
  Future<User> Function(Map<String, String> variables) get mutationFn => 
    (data) => api.createUser(data);

  @override
  MutationOptions<User, Map<String, String>>? get options => MutationOptions(
    onSuccess: (user) {
      print('User created: ${user.name}');
    },
    onError: (error) {
      print('Error: $error');
    },
  );
}

class CreateUserForm extends StatefulWidget {
  @override
  State<CreateUserForm> createState() => _CreateUserFormState();
}

class _CreateUserFormState extends State<CreateUserForm> {
  final _nameController = TextEditingController();
  final _emailController = TextEditingController();
  
  @override
  Widget build(BuildContext context) {
    return BlocProvider(
      create: (context) => CreateUserFormMutationCubit(),
      child: BlocBuilder<CreateUserFormMutationCubit, MutationState<User>>(
        builder: (context, state) {
          return Column(
            children: [
              TextField(
                controller: _nameController,
                decoration: InputDecoration(labelText: 'Name'),
              ),
              TextField(
                controller: _emailController,
                decoration: InputDecoration(labelText: 'Email'),
              ),
              ElevatedButton(
                onPressed: state.isLoading
                    ? null
                    : () {
                        context.read<CreateUserFormMutationCubit>().mutate({
                          'name': _nameController.text,
                          'email': _emailController.text,
                        });
                      },
                child: state.isLoading
                    ? CircularProgressIndicator()
                    : Text('Create User'),
              ),
            ],
          );
        },
      ),
    );
  }
}
```

## Cache Invalidation After Mutation

After a mutation succeeds, invalidate related queries:

```dart
class DeleteUserMutationCubit extends MutationCubit<void, String> {
  @override
  Future<void> Function(String variables) get mutationFn => 
    (id) => api.deleteUser(id);

  @override
  MutationOptions<void, String>? get options => MutationOptions(
    onSuccess: () {
      QueryClient().invalidateQuery('users');
    },
  );
}

class DeleteUserButton extends StatelessWidget {
  final String userId;
  
  const DeleteUserButton({required this.userId});
  
  @override
  Widget build(BuildContext context) {
    return BlocProvider(
      create: (context) => DeleteUserMutationCubit(),
      child: BlocBuilder<DeleteUserMutationCubit, MutationState<void>>(
        builder: (context, state) {
          return IconButton(
            icon: Icon(Icons.delete),
            onPressed: state.isLoading ? null : () {
              context.read<DeleteUserMutationCubit>().mutate(userId);
            },
          );
        },
      ),
    );
  }
}
```

## Optimistic Updates

Update the cache immediately for instant UX, then rollback on error:

```dart
class UpdateUserMutationCubit extends MutationCubit<User, User> {
  @override
  Future<User> Function(User variables) get mutationFn => 
    (updatedUser) => api.updateUser(updatedUser);

  @override
  MutationOptions<User, User>? get options => MutationOptions(
    onMutate: (updatedUser) {
      final users = QueryClient().getQueryData<List<User>>('users');
      if (users != null) {
        final optimistic = users.map((u) => 
          u.id == updatedUser.id ? updatedUser : u
        ).toList();
        
        QueryClient().setQueryData('users', optimistic);
      }
    },
    onSuccess: (user) {
      QueryClient().invalidateQuery('users');
    },
    onError: (error) {
      QueryClient().invalidateQuery('users');
    },
  );
}

class UpdateUserButton extends StatelessWidget {
  final User user;
  
  const UpdateUserButton({required this.user});
  
  @override
  Widget build(BuildContext context) {
    return BlocProvider(
      create: (context) => UpdateUserMutationCubit(),
      child: BlocBuilder<UpdateUserMutationCubit, MutationState<User>>(
        builder: (context, state) {
          return ElevatedButton(
            onPressed: () {
              context.read<UpdateUserMutationCubit>().mutate(user);
            },
            child: Text('Update'),
          );
        },
      ),
    );
  }
}
```

## Multiple Mutations

Handle multiple mutations in one screen:

```dart
class UpdateUserMutationCubit extends MutationCubit<User, User> {
  @override
  Future<User> Function(User variables) get mutationFn => 
    (updatedUser) => api.updateUser(updatedUser);
}

class DeleteUserMutationCubit extends MutationCubit<void, String> {
  @override
  Future<void> Function(String variables) get mutationFn => 
    (userId) => api.deleteUser(userId);
}

class UserActions extends StatelessWidget {
  final User user;
  
  const UserActions({required this.user});
  
  @override
  Widget build(BuildContext context) {
    return MultiBlocProvider(
      providers: [
        BlocProvider(create: (context) => UpdateUserMutationCubit()),
        BlocProvider(create: (context) => DeleteUserMutationCubit()),
      ],
      child: BlocBuilder<UpdateUserMutationCubit, MutationState<User>>(
        builder: (context, updateState) {
          return BlocBuilder<DeleteUserMutationCubit, MutationState<void>>(
            builder: (context, deleteState) {
              return Row(
                children: [
                  IconButton(
                    icon: Icon(Icons.edit),
                    onPressed: updateState.isLoading ? null : () {
                      context.read<UpdateUserMutationCubit>().mutate(user);
                    },
                  ),
                  IconButton(
                    icon: Icon(Icons.delete),
                    onPressed: deleteState.isLoading ? null : () {
                      context.read<DeleteUserMutationCubit>().mutate(user.id);
                    },
                  ),
                ],
              );
            },
          );
        },
      ),
    );
  }
}
```

## Error Handling

Handle errors with retry functionality:

```dart
class CreateUserMutationCubit extends MutationCubit<User, String> {
  @override
  Future<User> Function(String variables) get mutationFn => 
    (name) => api.createUser(name);
}

class CreateUserScreen extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text('Create User')),
      body: BlocProvider(
        create: (context) => CreateUserMutationCubit(),
        child: BlocBuilder<CreateUserMutationCubit, MutationState<User>>(
          builder: (context, state) {
            if (state.hasError) {
              return Column(
                children: [
                  Text('Error: ${state.error}'),
                  ElevatedButton(
                    onPressed: () {
                      context.read<CreateUserMutationCubit>().mutate('John Doe');
                    },
                    child: Text('Retry'),
                  ),
                ],
              );
            }
            
            return ElevatedButton(
              onPressed: state.isLoading ? null : () {
                context.read<CreateUserMutationCubit>().mutate('John Doe');
              },
              child: state.isLoading 
                ? CircularProgressIndicator()
                : Text('Create User'),
            );
          },
        ),
      ),
    );
  }
}
```

## Resetting Mutation State

Reset mutation state to start fresh:

```dart
class CreateUserMutationCubit extends MutationCubit<User, String> {
  @override
  Future<User> Function(String variables) get mutationFn => 
    (name) => api.createUser(name);
}

class CreateUserScreen extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text('Create User')),
      body: BlocProvider(
        create: (context) => CreateUserMutationCubit(),
        child: BlocBuilder<CreateUserMutationCubit, MutationState<User>>(
          builder: (context, state) {
            return Column(
              children: [
                ElevatedButton(
                  onPressed: state.isLoading ? null : () {
                    context.read<CreateUserMutationCubit>().mutate('John Doe');
                  },
                  child: Text('Create User'),
                ),
                if (state.hasData || state.hasError)
                  ElevatedButton(
                    onPressed: () {
                      context.read<CreateUserMutationCubit>().reset();
                    },
                    child: Text('Reset'),
                  ),
              ],
            );
          },
        ),
      ),
    );
  }
}
```

## Type Safety

Full generic type support ensures compile-time safety:

```dart
class CreateUserMutationCubit extends MutationCubit<User, String> {
  @override
  Future<User> Function(String variables) get mutationFn => 
    (name) => api.createUser(name);
}

class TypeSafeCreateUserScreen extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text('Create User')),
      body: BlocProvider(
        create: (context) => CreateUserMutationCubit(),
        child: BlocBuilder<CreateUserMutationCubit, MutationState<User>>(
          builder: (context, state) {
            return ElevatedButton(
              onPressed: state.isLoading ? null : () {
                context.read<CreateUserMutationCubit>().mutate('John Doe');
              },
              child: Text('Create User'),
            );
          },
        ),
      ),
    );
  }
}
```

## Common Patterns

### Loading Button

```dart
class CreateUserButton extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return BlocProvider(
      create: (context) => CreateUserMutationCubit(),
      child: BlocBuilder<CreateUserMutationCubit, MutationState<User>>(
        builder: (context, state) {
          return ElevatedButton(
            onPressed: state.isLoading ? null : () {
              context.read<CreateUserMutationCubit>().mutate('John Doe');
            },
            child: state.isLoading
                ? SizedBox(
                    width: 16,
                    height: 16,
                    child: CircularProgressIndicator(strokeWidth: 2),
                  )
                : Text('Create User'),
          );
        },
      ),
    );
  }
}
```

### Success Feedback

```dart
class CreateUserMutationCubit extends MutationCubit<User, String> {
  @override
  Future<User> Function(String variables) get mutationFn => 
    (name) => api.createUser(name);

  @override
  MutationOptions<User, String>? get options => MutationOptions(
    onSuccess: (user) {
      print('User created: ${user.name}');
    },
  );
}

class CreateUserScreen extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text('Create User')),
      body: BlocProvider(
        create: (context) => CreateUserMutationCubit(),
        child: BlocConsumer<CreateUserMutationCubit, MutationState<User>>(
          listener: (context, state) {
            if (state.hasData) {
              ScaffoldMessenger.of(context).showSnackBar(
                SnackBar(
                  content: Text('User created: ${state.data!.name}'),
                  backgroundColor: Colors.green,
                ),
              );
            }
          },
          builder: (context, state) {
            return ElevatedButton(
              onPressed: state.isLoading ? null : () {
                context.read<CreateUserMutationCubit>().mutate('John Doe');
              },
              child: Text('Create User'),
            );
          },
        ),
      ),
    );
  }
}
```

### Form Validation

```dart
class CreateUserForm extends StatefulWidget {
  @override
  State<CreateUserForm> createState() => _CreateUserFormState();
}

class _CreateUserFormState extends State<CreateUserForm> {
  final _formKey = GlobalKey<FormState>();
  final _nameController = TextEditingController();
  
  @override
  Widget build(BuildContext context) {
    return BlocProvider(
      create: (context) => CreateUserMutationCubit(),
      child: BlocBuilder<CreateUserMutationCubit, MutationState<User>>(
        builder: (context, state) {
          return Form(
            key: _formKey,
            child: Column(
              children: [
                TextFormField(
                  controller: _nameController,
                  decoration: InputDecoration(labelText: 'Name'),
                  validator: (value) {
                    if (value == null || value.isEmpty) {
                      return 'Name is required';
                    }
                    return null;
                  },
                ),
                ElevatedButton(
                  onPressed: state.isLoading ? null : () {
                    if (_formKey.currentState!.validate()) {
                      context.read<CreateUserMutationCubit>().mutate(_nameController.text);
                    }
                  },
                  child: Text('Create User'),
                ),
              ],
            ),
          );
        },
      ),
    );
  }
}
```

## Performance Tips

1. **Use optimistic updates** - Provide instant feedback
2. **Handle errors gracefully** - Don't leave users stuck
3. **Invalidate related queries** - Keep data fresh
4. **Use proper types** - Leverage compile-time safety
5. **Provide loading states** - Show progress to users

## Next Steps

- **[QueryCubit](/docs/bloc/query-cubit)** - Learn about queries
- **[Bloc Patterns](/docs/bloc/bloc-patterns)** - Best practices
- **[Testing](/docs/bloc/testing)** - Testing strategies
- **[Examples](/docs/bloc/examples)** - Complete working examples
