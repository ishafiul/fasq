# Examples

Complete working examples using the Fasq Bloc adapter.

## Basic User Management

A complete example showing user listing, creation, and deletion:

```dart
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:fasq_bloc/fasq_bloc.dart';

class User {
  final String id;
  final String name;
  final String email;
  
  User({required this.id, required this.name, required this.email});
  
  factory User.fromJson(Map<String, dynamic> json) {
    return User(
      id: json['id'],
      name: json['name'],
      email: json['email'],
    );
  }
}

class ApiService {
  Future<List<User>> fetchUsers() async {
    await Future.delayed(Duration(seconds: 1)); // Simulate network
    return [
      User(id: '1', name: 'Alice', email: 'alice@example.com'),
      User(id: '2', name: 'Bob', email: 'bob@example.com'),
    ];
  }
  
  Future<User> createUser(Map<String, String> data) async {
    await Future.delayed(Duration(seconds: 1));
    return User(
      id: DateTime.now().millisecondsSinceEpoch.toString(),
      name: data['name']!,
      email: data['email']!,
    );
  }
  
  Future<void> deleteUser(String id) async {
    await Future.delayed(Duration(seconds: 1));
  }
}

final api = ApiService();

// Cubits
class UsersQueryCubit extends QueryCubit<List<User>> {
  UsersQueryCubit() : super(
    queryKey: 'users',
    queryFn: () => api.fetchUsers(),
  );
}

class CreateUserMutationCubit extends MutationCubit<User, Map<String, String>> {
  CreateUserMutationCubit() : super(
    mutationFn: (data) => api.createUser(data),
    options: MutationOptions(
      onSuccess: (user) {
        // Invalidate users query to refetch
        QueryClient().invalidateQuery('users');
      },
    ),
  );
}

class DeleteUserMutationCubit extends MutationCubit<void, String> {
  DeleteUserMutationCubit() : super(
    mutationFn: (id) => api.deleteUser(id),
    options: MutationOptions(
      onSuccess: (_, id) {
        // Invalidate users query to refetch
        QueryClient().invalidateQuery('users');
      },
    ),
  );
}

class UserManagementScreen extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text('User Management')),
      body: MultiBlocProvider(
        providers: [
          BlocProvider(create: (context) => UsersQueryCubit()),
          BlocProvider(create: (context) => CreateUserMutationCubit()),
          BlocProvider(create: (context) => DeleteUserMutationCubit()),
        ],
        child: Column(
          children: [
            Expanded(child: UsersList()),
            Padding(
              padding: const EdgeInsets.all(16.0),
              child: ElevatedButton(
                onPressed: () => _showCreateUserDialog(context),
                child: Text('Add User'),
              ),
            ),
          ],
        ),
      ),
    );
  }
  
  void _showCreateUserDialog(BuildContext context) {
    showDialog(
      context: context,
      builder: (context) => CreateUserDialog(),
    );
  }
}

class UsersList extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return BlocBuilder<UsersQueryCubit, QueryState<List<User>>>(
      builder: (context, state) {
        if (state.isLoading) {
          return Center(child: CircularProgressIndicator());
        }
        
        if (state.hasError) {
          return Center(
            child: Column(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                Text('Error: ${state.error}'),
                ElevatedButton(
                  onPressed: () => context.read<UsersQueryCubit>().fetch(),
                  child: Text('Retry'),
                ),
              ],
            ),
          );
        }
        
        if (state.hasData) {
          return ListView.builder(
            itemCount: state.data!.length,
            itemBuilder: (context, index) {
              final user = state.data![index];
              return UserTile(user: user);
            },
          );
        }
        
        return Center(child: Text('No users found'));
      },
    );
  }
}

class UserTile extends StatelessWidget {
  final User user;
  
  const UserTile({required this.user});
  
  @override
  Widget build(BuildContext context) {
    return BlocBuilder<DeleteUserMutationCubit, MutationState<void>>(
      builder: (context, deleteState) {
        return ListTile(
          title: Text(user.name),
          subtitle: Text(user.email),
          trailing: IconButton(
            icon: Icon(Icons.delete),
            onPressed: deleteState.isLoading ? null : () {
              context.read<DeleteUserMutationCubit>().mutate(user.id);
            },
          ),
        );
      },
    );
  }
}

class CreateUserDialog extends StatefulWidget {
  @override
  State<CreateUserDialog> createState() => _CreateUserDialogState();
}

class _CreateUserDialogState extends State<CreateUserDialog> {
  final _nameController = TextEditingController();
  final _emailController = TextEditingController();
  
  @override
  Widget build(BuildContext context) {
    return BlocProvider(
      create: (context) => CreateUserMutationCubit(),
      child: BlocBuilder<CreateUserMutationCubit, MutationState<User>>(
        builder: (context, createState) {
          return AlertDialog(
            title: Text('Create User'),
            content: Column(
              mainAxisSize: MainAxisSize.min,
              children: [
                TextField(
                  controller: _nameController,
                  decoration: InputDecoration(labelText: 'Name'),
                ),
                TextField(
                  controller: _emailController,
                  decoration: InputDecoration(labelText: 'Email'),
                ),
              ],
            ),
            actions: [
              TextButton(
                onPressed: () => Navigator.pop(context),
                child: Text('Cancel'),
              ),
              ElevatedButton(
                onPressed: createState.isLoading ? null : () {
                  context.read<CreateUserMutationCubit>().mutate({
                    'name': _nameController.text,
                    'email': _emailController.text,
                  });
                  Navigator.pop(context);
                },
                child: createState.isLoading
                    ? CircularProgressIndicator()
                    : Text('Create'),
              ),
            ],
          );
        },
      ),
    );
  }
}
```

## Pagination Example

Implementing pagination with Bloc:

```dart
class PaginatedUsersCubit extends Cubit<List<User>> {
  PaginatedUsersCubit() : super([]);
  
  Future<void> loadPage(int page) async {
    final users = await api.fetchUsersPage(page: page, limit: 10);
    emit([...state, ...users]);
  }
  
  Future<void> loadInitialPage() async {
    await loadPage(1);
  }
}

class PaginatedUsersScreen extends StatefulWidget {
  @override
  State<PaginatedUsersScreen> createState() => _PaginatedUsersScreenState();
}

class _PaginatedUsersScreenState extends State<PaginatedUsersScreen> {
  int _currentPage = 1;
  
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text('Paginated Users')),
      body: BlocProvider(
        create: (context) => PaginatedUsersCubit()..loadInitialPage(),
        child: BlocBuilder<PaginatedUsersCubit, List<User>>(
          builder: (context, users) {
            return Column(
              children: [
                Expanded(
                  child: ListView.builder(
                    itemCount: users.length,
                    itemBuilder: (context, index) {
                      final user = users[index];
                      return ListTile(
                        title: Text(user.name),
                        subtitle: Text(user.email),
                      );
                    },
                  ),
                ),
                Row(
                  mainAxisAlignment: MainAxisAlignment.spaceEvenly,
                  children: [
                    ElevatedButton(
                      onPressed: _currentPage > 1 ? () {
                        setState(() => _currentPage--);
                        context.read<PaginatedUsersCubit>().loadPage(_currentPage);
                      } : null,
                      child: Text('Previous'),
                    ),
                    Text('Page $_currentPage'),
                    ElevatedButton(
                      onPressed: () {
                        setState(() => _currentPage++);
                        context.read<PaginatedUsersCubit>().loadPage(_currentPage);
                      },
                      child: Text('Next'),
                    ),
                  ],
                ),
              ],
            );
          },
        ),
      ),
    );
  }
}
```

## Real-time Updates

Simulating real-time updates with polling:

```dart
class RealTimeUsersCubit extends QueryCubit<List<User>> {
  RealTimeUsersCubit() : super(
    queryKey: 'users:realtime',
    queryFn: () => api.fetchUsers(),
    options: QueryOptions(
      refetchInterval: Duration(seconds: 30), // Poll every 30 seconds
      refetchOnWindowFocus: true, // Refetch when app regains focus
    ),
  );
}

class RealTimeUsersScreen extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text('Real-time Users'),
        actions: [
          IconButton(
            icon: Icon(Icons.refresh),
            onPressed: () {
              context.read<RealTimeUsersCubit>().fetch();
            },
          ),
        ],
      ),
      body: BlocProvider(
        create: (context) => RealTimeUsersCubit(),
        child: BlocBuilder<RealTimeUsersCubit, QueryState<List<User>>>(
          builder: (context, state) {
            return Column(
              children: [
                if (state.isFetching && !state.isLoading)
                  LinearProgressIndicator(),
                Expanded(
                  child: state.when(
                    idle: () => Center(child: Text('Ready to load users')),
                    loading: () => Center(child: CircularProgressIndicator()),
                    error: (error, stack) => Center(child: Text('Error: $error')),
                    data: (users) => ListView.builder(
                      itemCount: users.length,
                      itemBuilder: (context, index) {
                        final user = users[index];
                        return ListTile(
                          title: Text(user.name),
                          subtitle: Text(user.email),
                          trailing: Text('Updated: ${DateTime.now().toString().substring(11, 19)}'),
                        );
                      },
                    ),
                  ),
                ),
              ],
            );
          },
        ),
      ),
    );
  }
}
```

## Optimistic Updates

Implementing optimistic updates for instant feedback:

```dart
class UpdateUserMutationCubit extends MutationCubit<User, User> {
  UpdateUserMutationCubit() : super(
    mutationFn: (user) => api.updateUser(user),
    options: MutationOptions(
      onMutate: (updatedUser) {
        // Optimistically update cache
        final users = QueryClient().getQueryData<List<User>>('users');
        if (users != null) {
          final optimistic = users.map((u) => 
            u.id == updatedUser.id ? updatedUser : u
          ).toList();
          
          QueryClient().setQueryData('users', optimistic);
        }
      },
      onSuccess: (user) {
        // Invalidate to get fresh data
        QueryClient().invalidateQuery('users');
      },
      onError: (error) {
        // Rollback on error
        QueryClient().invalidateQuery('users');
      },
    ),
  );
}

class OptimisticUserScreen extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text('Optimistic Updates')),
      body: MultiBlocProvider(
        providers: [
          BlocProvider(create: (context) => UsersQueryCubit()),
          BlocProvider(create: (context) => UpdateUserMutationCubit()),
        ],
        child: BlocBuilder<UsersQueryCubit, QueryState<List<User>>>(
          builder: (context, usersState) {
            return usersState.when(
              loading: () => Center(child: CircularProgressIndicator()),
              error: (error, stack) => Center(child: Text('Error: $error')),
              data: (users) => ListView.builder(
                itemCount: users.length,
                itemBuilder: (context, index) {
                  final user = users[index];
                  return UserTileWithUpdate(user: user);
                },
              ),
            );
          },
        ),
      ),
    );
  }
}

class UserTileWithUpdate extends StatelessWidget {
  final User user;
  
  const UserTileWithUpdate({required this.user});
  
  @override
  Widget build(BuildContext context) {
    return BlocBuilder<UpdateUserMutationCubit, MutationState<User>>(
      builder: (context, updateState) {
        return ListTile(
          title: Text(user.name),
          subtitle: Text(user.email),
          trailing: Row(
            mainAxisSize: MainAxisSize.min,
            children: [
              IconButton(
                icon: Icon(Icons.edit),
                onPressed: updateState.isLoading ? null : () {
                  final updatedUser = User(
                    id: user.id,
                    name: '${user.name} (Updated)',
                    email: user.email,
                  );
                  context.read<UpdateUserMutationCubit>().mutate(updatedUser);
                },
              ),
            ],
          ),
        );
      },
    );
  }
}
```

## Search Functionality

Implementing search with debouncing:

```dart
class SearchQueryCubit extends Cubit<String> {
  Timer? _debounceTimer;
  
  SearchQueryCubit() : super('');
  
  void updateQuery(String query) {
    _debounceTimer?.cancel();
    _debounceTimer = Timer(Duration(milliseconds: 500), () {
      emit(query);
    });
  }
  
  @override
  Future<void> close() {
    _debounceTimer?.cancel();
    return super.close();
  }
}

class SearchResultsCubit extends QueryCubit<List<User>> {
  SearchResultsCubit(String query) : super(
    queryKey: 'search:$query',
    queryFn: () => api.searchUsers(query),
    options: QueryOptions(
      enabled: query.isNotEmpty && query.length >= 2,
      staleTime: Duration(minutes: 5), // Cache search results
    ),
  );
}

class SearchScreen extends StatefulWidget {
  @override
  State<SearchScreen> createState() => _SearchScreenState();
}

class _SearchScreenState extends State<SearchScreen> {
  final _searchController = TextEditingController();
  
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text('Search Users')),
      body: MultiBlocProvider(
        providers: [
          BlocProvider(create: (context) => SearchQueryCubit()),
        ],
        child: Column(
          children: [
            Padding(
              padding: const EdgeInsets.all(16.0),
              child: TextField(
                controller: _searchController,
                decoration: InputDecoration(
                  labelText: 'Search users',
                  prefixIcon: Icon(Icons.search),
                ),
                onChanged: (value) {
                  context.read<SearchQueryCubit>().updateQuery(value);
                },
              ),
            ),
            Expanded(
              child: BlocBuilder<SearchQueryCubit, String>(
                builder: (context, searchQuery) {
                  return BlocProvider(
                    create: (context) => SearchResultsCubit(searchQuery),
                    child: BlocBuilder<SearchResultsCubit, QueryState<List<User>>>(
                      builder: (context, searchState) {
                        return searchState.when(
                          idle: () => Center(child: Text('Enter a search term')),
                          loading: () => Center(child: CircularProgressIndicator()),
                          error: (error, stack) => Center(child: Text('Error: $error')),
                          data: (results) => results.isEmpty
                              ? Center(child: Text('No results found'))
                              : ListView.builder(
                                  itemCount: results.length,
                                  itemBuilder: (context, index) {
                                    final user = results[index];
                                    return ListTile(
                                      title: Text(user.name),
                                      subtitle: Text(user.email),
                                    );
                                  },
                                ),
                        );
                      },
                    ),
                  );
                },
              ),
            ),
          ],
        ),
      ),
    );
  }
}
```

## Form Handling

Complete form handling with validation:

```dart
class CreateUserFormCubit extends Cubit<CreateUserFormState> {
  CreateUserFormCubit() : super(CreateUserFormState.initial());
  
  void updateName(String name) {
    emit(state.copyWith(
      name: name,
      isValid: name.isNotEmpty && state.email.isNotEmpty,
      nameError: name.isEmpty ? 'Name is required' : null,
    ));
  }
  
  void updateEmail(String email) {
    emit(state.copyWith(
      email: email,
      isValid: state.name.isNotEmpty && email.isNotEmpty,
      emailError: email.isEmpty ? 'Email is required' : null,
    ));
  }
  
  void reset() {
    emit(CreateUserFormState.initial());
  }
}

class CreateUserFormState {
  final String name;
  final String email;
  final bool isValid;
  final String? nameError;
  final String? emailError;
  
  CreateUserFormState({
    required this.name,
    required this.email,
    required this.isValid,
    this.nameError,
    this.emailError,
  });
  
  factory CreateUserFormState.initial() => CreateUserFormState(
    name: '',
    email: '',
    isValid: false,
  );
  
  CreateUserFormState copyWith({
    String? name,
    String? email,
    bool? isValid,
    String? nameError,
    String? emailError,
  }) {
    return CreateUserFormState(
      name: name ?? this.name,
      email: email ?? this.email,
      isValid: isValid ?? this.isValid,
      nameError: nameError,
      emailError: emailError,
    );
  }
}

class CreateUserForm extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text('Create User')),
      body: MultiBlocProvider(
        providers: [
          BlocProvider(create: (context) => CreateUserFormCubit()),
          BlocProvider(create: (context) => CreateUserMutationCubit()),
        ],
        child: Padding(
          padding: const EdgeInsets.all(16.0),
          child: BlocBuilder<CreateUserFormCubit, CreateUserFormState>(
            builder: (context, formState) {
              return BlocBuilder<CreateUserMutationCubit, MutationState<User>>(
                builder: (context, mutationState) {
                  return Form(
                    child: Column(
                      children: [
                        TextFormField(
                          decoration: InputDecoration(labelText: 'Name'),
                          onChanged: (value) {
                            context.read<CreateUserFormCubit>().updateName(value);
                          },
                          validator: (value) => formState.nameError,
                        ),
                        SizedBox(height: 16),
                        TextFormField(
                          decoration: InputDecoration(labelText: 'Email'),
                          onChanged: (value) {
                            context.read<CreateUserFormCubit>().updateEmail(value);
                          },
                          validator: (value) => formState.emailError,
                        ),
                        SizedBox(height: 24),
                        ElevatedButton(
                          onPressed: formState.isValid && !mutationState.isLoading
                              ? () {
                                  context.read<CreateUserMutationCubit>().mutate({
                                    'name': formState.name,
                                    'email': formState.email,
                                  });
                                  context.read<CreateUserFormCubit>().reset();
                                }
                              : null,
                          child: mutationState.isLoading
                              ? CircularProgressIndicator()
                              : Text('Create User'),
                        ),
                      ],
                    ),
                  );
                },
              );
            },
          ),
        ),
      ),
    );
  }
}
```

## Error Boundary

Implementing error boundaries with Bloc:

```dart
class ErrorBoundaryCubit extends Cubit<Object?> {
  ErrorBoundaryCubit() : super(null);
  
  void setError(Object error) {
    emit(error);
  }
  
  void clearError() {
    emit(null);
  }
}

class ErrorBoundary extends StatelessWidget {
  final Widget child;
  final Widget Function(Object error)? errorBuilder;
  
  const ErrorBoundary({
    required this.child,
    this.errorBuilder,
  });
  
  @override
  Widget build(BuildContext context) {
    return BlocProvider(
      create: (context) => ErrorBoundaryCubit(),
      child: BlocBuilder<ErrorBoundaryCubit, Object?>(
        builder: (context, error) {
          if (error != null) {
            return errorBuilder?.call(error) ?? 
              Center(child: Text('Error: $error'));
          }
          
          return child;
        },
      ),
    );
  }
}

class UsersScreenWithErrorBoundary extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return ErrorBoundary(
      errorBuilder: (error) => Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(Icons.error, size: 64, color: Colors.red),
            SizedBox(height: 16),
            Text('Something went wrong'),
            SizedBox(height: 8),
            Text('$error'),
            SizedBox(height: 16),
            ElevatedButton(
              onPressed: () => Navigator.pop(context),
              child: Text('Go Back'),
            ),
          ],
        ),
      ),
      child: UserManagementScreen(),
    );
  }
}
```

## Performance Optimization

Optimizing performance with proper cache configuration:

```dart
class OptimizedUsersCubit extends QueryCubit<List<User>> {
  OptimizedUsersCubit() : super(
    queryKey: 'users',
    queryFn: () => api.fetchUsers(),
    options: QueryOptions(
      staleTime: Duration(minutes: 10), // Keep fresh for 10 minutes
      cacheTime: Duration(minutes: 30), // Keep in cache for 30 minutes
      refetchOnWindowFocus: false, // Don't refetch on focus
      refetchOnMount: false, // Don't refetch on mount if data exists
    ),
  );
}

class OptimizedUsersScreen extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text('Optimized Users')),
      body: BlocProvider(
        create: (context) => OptimizedUsersCubit(),
        child: BlocBuilder<OptimizedUsersCubit, QueryState<List<User>>>(
          builder: (context, state) {
            return state.when(
              loading: () => Center(child: CircularProgressIndicator()),
              error: (error, stack) => Center(child: Text('Error: $error')),
              data: (users) => ListView.builder(
                itemCount: users.length,
                itemBuilder: (context, index) {
                  final user = users[index];
                  return ListTile(
                    title: Text(user.name),
                    subtitle: Text(user.email),
                  );
                },
              ),
            );
          },
        ),
      ),
    );
  }
}
```

## Next Steps

- **[QueryCubit](/docs/bloc/query-cubit)** - Learn about the QueryCubit
- **[MutationCubit](/docs/bloc/mutation-cubit)** - Learn about the MutationCubit
- **[Bloc Patterns](/docs/bloc/bloc-patterns)** - Best practices and patterns
- **[Testing](/docs/bloc/testing)** - Testing strategies
